<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Frozen Factory</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a12;
            overflow: hidden;
            font-family: 'Courier New', monospace;
        }

        #gameCanvas {
            display: block;
            cursor: crosshair;
        }

        /* Theme Selection Modal */
        #themeModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        #themeModal h1 {
            color: #88ccff;
            font-size: 48px;
            margin-bottom: 10px;
            text-shadow: 0 0 20px #88ccff;
        }

        #themeModal h2 {
            color: #aaa;
            font-size: 18px;
            margin-bottom: 40px;
        }

        .theme-options {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .theme-btn {
            width: 150px;
            height: 100px;
            border: 3px solid #333;
            border-radius: 10px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: all 0.3s;
            font-family: inherit;
        }

        .theme-btn:hover {
            transform: scale(1.1);
            border-color: #fff;
        }

        .theme-btn span {
            font-size: 14px;
            margin-top: 10px;
        }

        #theme-cold { background: linear-gradient(135deg, #1a3a5c, #0d1f33); }
        #theme-cold span { color: #88ccff; }

        #theme-warm { background: linear-gradient(135deg, #5c3a1a, #331f0d); }
        #theme-warm span { color: #ffaa44; }

        #theme-green { background: linear-gradient(135deg, #1a3a1a, #0d1f0d); }
        #theme-green span { color: #44ff88; }

        #theme-contrast { background: linear-gradient(135deg, #000, #222); }
        #theme-contrast span { color: #fff; }

        /* UI Overlay */
        #ui {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: none;
        }

        #ui > * {
            pointer-events: auto;
        }

        /* Top Bar */
        #topBar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: var(--ui-bg);
            border-bottom: 2px solid var(--ui-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
        }

        .resource-bar {
            display: flex;
            gap: 15px;
        }

        .resource-item {
            display: flex;
            align-items: center;
            gap: 5px;
            color: var(--ui-text);
            font-size: 14px;
        }

        .resource-icon {
            width: 20px;
            height: 20px;
            border-radius: 3px;
        }

        .status-bar {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        #dayNightIndicator {
            width: 200px;
            height: 30px;
            background: #111;
            border-radius: 15px;
            overflow: hidden;
            position: relative;
        }

        #dayNightFill {
            height: 100%;
            background: linear-gradient(90deg, #ffcc00, #ff6600);
            transition: width 0.5s;
        }

        #dayNightText {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 12px;
            text-shadow: 0 0 5px #000;
        }

        #tempIndicator {
            color: var(--ui-text);
            font-size: 14px;
        }

        /* Bottom Bar */
        #bottomBar {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 120px;
            background: var(--ui-bg);
            border-top: 2px solid var(--ui-border);
            display: flex;
            padding: 10px 20px;
            gap: 20px;
        }

        #buildMenu {
            width: 400px;
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            overflow-y: auto;
        }

        .build-item {
            width: 50px;
            height: 50px;
            background: var(--ui-button);
            border: 2px solid var(--ui-border);
            border-radius: 5px;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            transition: all 0.2s;
            padding: 2px;
            box-sizing: border-box;
        }

        .build-item img {
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        .build-item:hover {
            background: var(--ui-highlight);
            transform: scale(1.1);
            z-index: 10;
        }

        .build-item.selected {
            border-color: var(--ui-accent);
            box-shadow: 0 0 10px var(--ui-accent);
        }

        #selectedInfo {
            flex: 1;
            background: var(--ui-button);
            border-radius: 5px;
            padding: 10px;
            color: var(--ui-text);
            overflow: hidden;
        }

        #robotStatus {
            width: 200px;
            background: var(--ui-button);
            border-radius: 5px;
            padding: 10px;
            color: var(--ui-text);
        }

        .status-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 12px;
        }

        .status-bar-mini {
            width: 100%;
            height: 8px;
            background: #222;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 2px;
        }

        .status-bar-fill {
            height: 100%;
            transition: width 0.3s;
        }

        /* Minimap */
        #minimap {
            position: absolute;
            bottom: 140px;
            left: 20px;
            width: 150px;
            height: 150px;
            background: rgba(0,0,0,0.8);
            border: 2px solid var(--ui-border);
            border-radius: 5px;
        }

        #minimapCanvas {
            width: 100%;
            height: 100%;
        }

        /* Inventory Panel - Fullscreen */
        #inventoryPanel {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        #inventoryPanel h3 {
            color: var(--ui-accent);
            margin-bottom: 20px;
            font-size: 24px;
        }

        #inventoryGrid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            padding: 20px;
            background: var(--ui-bg);
            border: 2px solid var(--ui-border);
            border-radius: 10px;
        }

        .inv-slot {
            width: 80px;
            height: 80px;
            background: var(--ui-button);
            border: 2px solid var(--ui-border);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 12px;
            color: var(--ui-text);
            cursor: pointer;
            transition: all 0.2s;
        }

        .inv-slot:hover {
            background: var(--ui-highlight);
            transform: scale(1.05);
        }

        .inv-slot .item-icon {
            font-size: 28px;
            margin-bottom: 5px;
        }

        .inv-slot .item-count {
            font-size: 14px;
            font-weight: bold;
        }

        #inventoryClose {
            margin-top: 20px;
            padding: 10px 30px;
            background: var(--ui-button);
            border: 2px solid var(--ui-border);
            border-radius: 5px;
            color: var(--ui-text);
            cursor: pointer;
            font-size: 16px;
        }

        #inventoryClose:hover {
            background: var(--ui-highlight);
        }

        .inv-slot:hover {
            border-color: var(--ui-accent);
        }

        /* Pause Menu */
        #pauseMenu {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--ui-bg);
            border: 3px solid var(--ui-border);
            border-radius: 10px;
            padding: 30px;
            display: none;
            z-index: 100;
        }

        #pauseMenu h2 {
            color: var(--ui-text);
            text-align: center;
            margin-bottom: 20px;
        }

        .pause-btn {
            display: block;
            width: 200px;
            padding: 10px;
            margin: 10px auto;
            background: var(--ui-button);
            border: 2px solid var(--ui-border);
            border-radius: 5px;
            color: var(--ui-text);
            font-family: inherit;
            font-size: 16px;
            cursor: pointer;
        }

        .pause-btn:hover {
            background: var(--ui-highlight);
        }

        /* Cheat Menu */
        #cheatMenu {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(50, 0, 0, 0.95);
            border: 3px solid #ff0000;
            border-radius: 10px;
            padding: 30px;
            display: none;
            z-index: 200;
        }

        #cheatMenu h2 {
            color: #ff4444;
            text-align: center;
            margin-bottom: 20px;
        }

        .cheat-btn {
            display: block;
            width: 200px;
            padding: 10px;
            margin: 10px auto;
            background: #330000;
            border: 2px solid #660000;
            border-radius: 5px;
            color: #ff6666;
            font-family: inherit;
            font-size: 14px;
            cursor: pointer;
        }

        .cheat-btn:hover {
            background: #550000;
        }

        .cheat-btn.active {
            background: #660000;
            border-color: #ff0000;
        }

        /* Tooltips */
        #tooltip {
            position: fixed;
            background: var(--ui-bg);
            border: 2px solid var(--ui-border);
            border-radius: 5px;
            padding: 10px;
            color: var(--ui-text);
            font-size: 12px;
            max-width: 250px;
            display: none;
            z-index: 500;
            pointer-events: none;
        }

        /* Machine Menu */
        #machineMenu {
            position: fixed;
            background: var(--ui-bg);
            border: 2px solid var(--ui-border);
            border-radius: 5px;
            padding: 15px;
            display: none;
            z-index: 150;
            min-width: 200px;
        }

        #machineMenu h3 {
            color: var(--ui-accent);
            margin-bottom: 10px;
        }

        .machine-stat {
            color: var(--ui-text);
            font-size: 12px;
            margin: 5px 0;
        }

        /* Trading Modal */
        #tradeModal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--ui-bg);
            border: 3px solid var(--ui-border);
            border-radius: 10px;
            padding: 20px;
            display: none;
            z-index: 200;
            min-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
        }

        #tradeModal h2 {
            color: var(--ui-accent);
            margin-bottom: 15px;
            text-align: center;
        }

        .trade-section {
            margin-bottom: 20px;
        }

        .trade-section h3 {
            color: var(--ui-text);
            font-size: 14px;
            margin-bottom: 10px;
            border-bottom: 1px solid var(--ui-border);
            padding-bottom: 5px;
        }

        .trade-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }

        .trade-item {
            background: var(--ui-button);
            border: 2px solid var(--ui-border);
            border-radius: 5px;
            padding: 10px;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
        }

        .trade-item:hover {
            border-color: var(--ui-accent);
            background: var(--ui-highlight);
        }

        .trade-item .icon {
            font-size: 24px;
            margin-bottom: 5px;
        }

        .trade-item .name {
            color: var(--ui-text);
            font-size: 11px;
            margin-bottom: 3px;
        }

        .trade-item .price {
            color: var(--ui-accent);
            font-size: 12px;
            font-weight: bold;
        }

        .trade-item.sell {
            border-color: #448844;
        }

        .trade-item.buy {
            border-color: #884444;
        }

        /* Planet Travel Modal */
        #travelModal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--ui-bg);
            border: 3px solid var(--ui-border);
            border-radius: 10px;
            padding: 20px;
            display: none;
            z-index: 200;
            min-width: 400px;
        }

        #travelModal h2 {
            color: var(--ui-accent);
            margin-bottom: 15px;
            text-align: center;
        }

        .planet-option {
            background: var(--ui-button);
            border: 2px solid var(--ui-border);
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .planet-option:hover {
            border-color: var(--ui-accent);
        }

        .planet-option.locked {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .planet-option h4 {
            color: var(--ui-accent);
            margin-bottom: 5px;
        }

        .planet-option p {
            color: var(--ui-text);
            font-size: 11px;
            margin: 2px 0;
        }

        .planet-warning {
            color: #ff6666;
            font-weight: bold;
        }

        /* Save Slots */
        .save-slots {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 20px;
        }

        .save-slot {
            width: 180px;
            padding: 15px;
            background: rgba(30, 40, 50, 0.9);
            border: 3px solid #334;
            border-radius: 10px;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s;
        }

        .save-slot:hover {
            border-color: #88ccff;
            transform: scale(1.05);
        }

        .save-slot.selected {
            border-color: #44ff88;
            box-shadow: 0 0 15px #44ff88;
        }

        .save-slot h3 {
            color: #88ccff;
            margin-bottom: 8px;
            font-size: 16px;
        }

        .save-slot .save-info {
            color: #888;
            font-size: 11px;
            margin: 3px 0;
        }

        .save-slot .save-info.exists {
            color: #aaa;
        }

        .save-slot .delete-save {
            margin-top: 10px;
            padding: 5px 10px;
            background: #533;
            border: 1px solid #755;
            border-radius: 5px;
            color: #faa;
            font-size: 10px;
            cursor: pointer;
        }

        .save-slot .delete-save:hover {
            background: #744;
        }

        /* Keybinds Button */
        #keybindsBtn {
            position: absolute;
            top: 70px;
            right: 20px;
            padding: 8px 15px;
            background: var(--ui-button);
            border: 2px solid var(--ui-border);
            border-radius: 5px;
            color: var(--ui-text);
            font-family: inherit;
            font-size: 12px;
            cursor: pointer;
        }

        #keybindsBtn:hover {
            background: var(--ui-highlight);
        }

        /* Keybinds Modal */
        #keybindsModal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--ui-bg);
            border: 3px solid var(--ui-border);
            border-radius: 10px;
            padding: 25px;
            display: none;
            z-index: 200;
            min-width: 350px;
            max-height: 80vh;
            overflow-y: auto;
        }

        #keybindsModal h2 {
            color: var(--ui-accent);
            margin-bottom: 20px;
            text-align: center;
        }

        .keybind-section {
            margin-bottom: 15px;
        }

        .keybind-section h3 {
            color: var(--ui-accent);
            font-size: 14px;
            margin-bottom: 8px;
            border-bottom: 1px solid var(--ui-border);
            padding-bottom: 5px;
        }

        .keybind-row {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            color: var(--ui-text);
            font-size: 12px;
        }

        .keybind-key {
            background: var(--ui-button);
            padding: 3px 8px;
            border-radius: 3px;
            font-family: monospace;
            min-width: 60px;
            text-align: center;
        }

        /* Notifications */
        #notifications {
            position: absolute;
            top: 80px;
            left: 20px;
            width: 300px;
        }

        .notification {
            background: var(--ui-bg);
            border-left: 4px solid var(--ui-accent);
            padding: 10px;
            margin-bottom: 10px;
            color: var(--ui-text);
            font-size: 12px;
            border-radius: 0 5px 5px 0;
            animation: slideIn 0.3s ease;
        }

        .notification.warning {
            border-color: #ffaa00;
        }

        .notification.danger {
            border-color: #ff4444;
        }

        @keyframes slideIn {
            from { transform: translateX(-100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
    </style>
</head>
<body>
    <!-- Theme Selection -->
    <div id="themeModal">
        <h1>FROZEN FACTORY</h1>
        <h2>Select Save Slot</h2>
        <div class="save-slots" id="saveSlots"></div>
        <h2 style="margin-top: 30px;">Select UI Theme</h2>
        <div class="theme-options">
            <button class="theme-btn" id="theme-cold" onclick="selectTheme('cold')">
                <span>Cold Blue</span>
            </button>
            <button class="theme-btn" id="theme-warm" onclick="selectTheme('warm')">
                <span>Warm Amber</span>
            </button>
            <button class="theme-btn" id="theme-green" onclick="selectTheme('green')">
                <span>Green Terminal</span>
            </button>
            <button class="theme-btn" id="theme-contrast" onclick="selectTheme('contrast')">
                <span>High Contrast</span>
            </button>
        </div>
    </div>

    <!-- Game Canvas -->
    <canvas id="gameCanvas"></canvas>

    <!-- UI Overlay -->
    <div id="ui">
        <!-- Top Bar -->
        <div id="topBar">
            <div class="resource-bar">
                <div class="resource-item">
                    <div class="resource-icon" style="background: #888;"></div>
                    <span id="res-iron">0</span>
                </div>
                <div class="resource-item">
                    <div class="resource-icon" style="background: #c77;"></div>
                    <span id="res-copper">0</span>
                </div>
                <div class="resource-item">
                    <div class="resource-icon" style="background: #333;"></div>
                    <span id="res-coal">0</span>
                </div>
                <div class="resource-item">
                    <div class="resource-icon" style="background: #88f;"></div>
                    <span id="res-crystal">0</span>
                </div>
                <div class="resource-item">
                    <div class="resource-icon" style="background: gold;"></div>
                    <span id="res-credits">0</span> CR
                </div>
            </div>
            <div class="status-bar">
                <div id="dayNightIndicator">
                    <div id="dayNightFill"></div>
                    <span id="dayNightText">DAY 00:00</span>
                </div>
                <div id="tempIndicator">üå°Ô∏è -10¬∞C</div>
            </div>
        </div>

        <!-- Bottom Bar -->
        <div id="bottomBar">
            <div id="buildMenu"></div>
            <div id="selectedInfo">
                <h4 style="color: var(--ui-accent);">Nothing Selected</h4>
                <p style="font-size: 12px;">Click on a machine or use build menu</p>
            </div>
            <div id="robotStatus">
                <h4 style="color: var(--ui-accent); margin-bottom: 10px;">Robot Status</h4>
                <div class="status-row">
                    <span>Battery</span>
                    <span id="batteryPercent">100%</span>
                </div>
                <div class="status-bar-mini">
                    <div class="status-bar-fill" id="batteryBar" style="background: #4f4; width: 100%;"></div>
                </div>
                <div class="status-row" style="margin-top: 10px;">
                    <span>Temperature</span>
                    <span id="robotTempVal">OK</span>
                </div>
                <div class="status-bar-mini">
                    <div class="status-bar-fill" id="tempBar" style="background: #4f4; width: 50%;"></div>
                </div>
                <div class="status-row" style="margin-top: 10px;">
                    <span>HP</span>
                    <span id="robotHPVal">100%</span>
                </div>
                <div class="status-bar-mini">
                    <div class="status-bar-fill" id="hpBar" style="background: #4f4; width: 100%;"></div>
                </div>
            </div>
        </div>

        <!-- Minimap -->
        <div id="minimap">
            <canvas id="minimapCanvas"></canvas>
        </div>

        <!-- Inventory Panel -->
        <div id="inventoryPanel">
            <h3>INVENTORY</h3>
            <div id="inventoryGrid"></div>
            <button id="inventoryClose" onclick="toggleInventory()">Close (I)</button>
        </div>

        <!-- Notifications -->
        <div id="notifications"></div>

        <!-- Keybinds Button -->
        <button id="keybindsBtn" onclick="toggleKeybinds()">‚å®Ô∏è Controls</button>
    </div>

    <!-- Keybinds Modal -->
    <div id="keybindsModal">
        <h2>‚å®Ô∏è Controls</h2>

        <div class="keybind-section">
            <h3>Movement</h3>
            <div class="keybind-row"><span>Move Robot</span><span class="keybind-key">WASD</span></div>
            <div class="keybind-row"><span>Pan Camera</span><span class="keybind-key">Middle Mouse</span></div>
            <div class="keybind-row"><span>Zoom</span><span class="keybind-key">Scroll</span></div>
            <div class="keybind-row"><span>Toggle Follow</span><span class="keybind-key">F</span></div>
        </div>

        <div class="keybind-section">
            <h3>Interaction</h3>
            <div class="keybind-row"><span>Interact / Place</span><span class="keybind-key">Left Click</span></div>
            <div class="keybind-row"><span>Machine Menu</span><span class="keybind-key">Right Click</span></div>
            <div class="keybind-row"><span>Pick Up / Extinguish</span><span class="keybind-key">E</span></div>
            <div class="keybind-row"><span>Drop Item</span><span class="keybind-key">Q</span></div>
            <div class="keybind-row"><span>Rotate Building</span><span class="keybind-key">R</span></div>
        </div>

        <div class="keybind-section">
            <h3>Menus</h3>
            <div class="keybind-row"><span>Build Menu</span><span class="keybind-key">Tab</span></div>
            <div class="keybind-row"><span>Inventory</span><span class="keybind-key">I</span></div>
            <div class="keybind-row"><span>Full Map</span><span class="keybind-key">M</span></div>
            <div class="keybind-row"><span>Pause</span><span class="keybind-key">Space</span></div>
            <div class="keybind-row"><span>Cancel / Close</span><span class="keybind-key">Esc</span></div>
        </div>

        <button class="pause-btn" onclick="toggleKeybinds()">Close</button>
    </div>

    <!-- Pause Menu -->
    <div id="pauseMenu">
        <h2>PAUSED</h2>
        <button class="pause-btn" onclick="resumeGame()">Resume</button>
        <button class="pause-btn" onclick="saveGame()">Save Game</button>
        <button class="pause-btn" onclick="showControls()">Controls</button>
        <button class="pause-btn" onclick="quitToMenu()">Quit to Menu</button>
    </div>

    <!-- Cheat Menu -->
    <div id="cheatMenu">
        <h2>üîß CHEAT MENU üîß</h2>
        <button class="cheat-btn" onclick="cheatAddBattery()">Add Battery</button>
        <button class="cheat-btn" onclick="cheatAddWarmth()">Add Warmth</button>
        <button class="cheat-btn" onclick="cheatAddItems()">Add Items</button>
        <button class="cheat-btn" id="cheatFreeCraft" onclick="cheatFreeCrafting()">Free Crafting</button>
        <button class="cheat-btn" onclick="cheatLantern()">Lantern (Reveal Map)</button>
        <button class="cheat-btn" id="cheatNoDeath" onclick="cheatNoDeath()">No Death</button>
        <button class="cheat-btn" id="cheatRocket" onclick="cheatRocketLauncher()">Rocket Launcher</button>
        <button class="cheat-btn" onclick="closeCheatMenu()">Close</button>
    </div>

    <!-- Tooltip -->
    <div id="tooltip"></div>

    <!-- Machine Menu -->
    <div id="machineMenu"></div>

    <!-- Trading Modal -->
    <div id="tradeModal">
        <h2 id="tradeTitle">Trading</h2>
        <div id="tradeContent"></div>
        <button class="pause-btn" onclick="closeTradeModal()">Close</button>
    </div>

    <!-- Planet Travel Modal -->
    <div id="travelModal">
        <h2>üöÄ Planet Travel</h2>
        <div id="travelContent"></div>
        <button class="pause-btn" onclick="closeTravelModal()">Cancel</button>
    </div>

<script>
// ==================== CONFIGURATION ====================
const CONFIG = {
    TILE_WIDTH: 64,
    TILE_HEIGHT: 32,
    MAP_SIZE: 512,
    SAVE_INTERVAL: 5000,
    INVENTORY_SIZE: 16,

    // Day/Night durations in ms per planet
    PLANETS: {
        terra_prime: { dayLength: 600000, nightLength: 900000, baseTemp: -10, name: 'Terra Prime' },
        frost_moon: { dayLength: 480000, nightLength: 1020000, baseTemp: -20, name: 'Frost Moon' },
        shadow_belt: { dayLength: 300000, nightLength: 1200000, baseTemp: -30, name: 'Shadow Belt' },
        ice_giant: { dayLength: 180000, nightLength: 1320000, baseTemp: -40, name: 'Ice Giant' },
        space_rock_024: { dayLength: 0, nightLength: Infinity, baseTemp: -50, name: 'Space Rock-024' }
    }
};

// ==================== THEMES ====================
const THEMES = {
    cold: {
        '--ui-bg': 'rgba(13, 31, 51, 0.95)',
        '--ui-border': '#1a4a7a',
        '--ui-text': '#88ccff',
        '--ui-accent': '#44aaff',
        '--ui-button': 'rgba(20, 50, 80, 0.9)',
        '--ui-highlight': 'rgba(40, 80, 120, 0.9)'
    },
    warm: {
        '--ui-bg': 'rgba(51, 31, 13, 0.95)',
        '--ui-border': '#7a4a1a',
        '--ui-text': '#ffcc88',
        '--ui-accent': '#ffaa44',
        '--ui-button': 'rgba(80, 50, 20, 0.9)',
        '--ui-highlight': 'rgba(120, 80, 40, 0.9)'
    },
    green: {
        '--ui-bg': 'rgba(13, 31, 13, 0.95)',
        '--ui-border': '#1a5a1a',
        '--ui-text': '#88ff88',
        '--ui-accent': '#44ff88',
        '--ui-button': 'rgba(20, 50, 20, 0.9)',
        '--ui-highlight': 'rgba(40, 80, 40, 0.9)'
    },
    contrast: {
        '--ui-bg': 'rgba(0, 0, 0, 0.95)',
        '--ui-border': '#ffffff',
        '--ui-text': '#ffffff',
        '--ui-accent': '#ffff00',
        '--ui-button': 'rgba(30, 30, 30, 0.9)',
        '--ui-highlight': 'rgba(60, 60, 60, 0.9)'
    }
};

// ==================== GAME STATE ====================
let game = {
    running: false,
    paused: false,
    theme: 'cold',
    cheatsEnabled: false,
    cheatsActive: {
        freeCrafting: false,
        noDeath: false,
        rocketLauncher: false
    },
    cheatBuffer: '',

    // Time
    dayTime: 0,
    isDay: true,
    planet: 'terra_prime',

    // Camera
    camera: {
        x: 0,
        y: 0,
        zoom: 1,
        following: true
    },

    // Robot
    robot: {
        x: 256,
        y: 256,
        vx: 0,
        vy: 0,
        battery: 100,
        maxBattery: 100,
        temperature: 20,
        hp: 100,
        maxHp: 100,
        frozen: false,
        inventory: [],
        heldItem: null
    },

    // World
    tiles: [],
    machines: [],
    resources: [],
    npcs: [],
    explored: [],
    particles: [],
    cables: [], // Power cable connections between machines

    // Cable tool state
    cableStart: null, // First machine selected for cable connection

    // Stats
    credits: 100,
    stats: {
        playtime: 0,
        machinesBuilt: 0,
        resourcesMined: 0
    },

    // Sun Tracker robots (autonomous units)
    sunTrackers: []
};

// ==================== RESOURCE TYPES ====================
const RESOURCES = {
    iron_ore: { name: 'Iron Ore', color: '#888888', icon: 'ÔøΩite', price: 2 },
    copper_ore: { name: 'Copper Ore', color: '#cc7744', icon: '‚Éù', price: 3 },
    coal: { name: 'Coal', color: '#333333', icon: 'ÔøΩite', price: 2 },
    crystal: { name: 'Crystal', color: '#8888ff', icon: '‚óá', price: 25 },
    dark_matter: { name: 'Dark Matter', color: '#8800ff', icon: '‚óà', price: 100 },
    quantum_ore: { name: 'Quantum Ore', color: '#00ffff', icon: '‚úß', price: 200 },
    iron_ingot: { name: 'Iron Ingot', color: '#aaaaaa', icon: '‚ñ¨', price: 8 },
    copper_ingot: { name: 'Copper Ingot', color: '#dd9966', icon: '‚ñ¨', price: 10 },
    steel: { name: 'Steel', color: '#cccccc', icon: '‚ñ∞', price: 20 },
    circuit: { name: 'Circuit', color: '#44ff44', icon: '‚äû', price: 50 },
    water: { name: 'Water', color: '#4488ff', icon: 'üíß', price: 5 },
    super_fuel: { name: 'Super Fuel', color: '#ff00ff', icon: '‚ö°', price: 500 },
    cable: { name: 'Cable', color: '#cc8844', icon: '~', price: 5 },
    pipe_item: { name: 'Pipe', color: '#556677', icon: '‚ïê', price: 4 },
    conveyor_item: { name: 'Conveyor', color: '#666666', icon: '‚Üí', price: 8 },
    heat_sink_item: { name: 'Heat Sink', color: '#7788aa', icon: '‚âã', price: 30 },
    solar_panel_item: { name: 'Solar Panel', color: '#4488cc', icon: '‚òÄ', price: 75 },
    battery_item: { name: 'Battery', color: '#44aa44', icon: 'üîã', price: 40 },
    engine_part: { name: 'Engine Part', color: '#888899', icon: '‚öô', price: 80 },
    ore_024: { name: '024 Ore', color: '#ff00ff', icon: '‚ú¥', price: 1000 }
};

// ==================== RECIPES ====================
const RECIPES = {
    furnace: [
        { inputs: { iron_ore: 2 }, output: { iron_ingot: 1 }, time: 5 },
        { inputs: { copper_ore: 2 }, output: { copper_ingot: 1 }, time: 5 },
        { inputs: { iron_ingot: 1, coal: 1 }, output: { steel: 1 }, time: 8 }
    ],
    assembler: [
        { inputs: { copper_ingot: 1 }, output: { cable: 5 }, time: 3 },
        { inputs: { iron_ingot: 2 }, output: { pipe: 3 }, time: 4 },
        { inputs: { iron_ingot: 1, copper_ingot: 1 }, output: { conveyor: 2 }, time: 5 },
        { inputs: { copper_ingot: 2, crystal: 1 }, output: { circuit: 1 }, time: 8 },
        { inputs: { copper_ingot: 4, iron_ingot: 2 }, output: { heat_sink: 1 }, time: 6 },
        { inputs: { crystal: 2, copper_ingot: 2, steel: 1 }, output: { solar_panel: 1 }, time: 12 },
        { inputs: { copper_ingot: 2, crystal: 1, iron_ingot: 1 }, output: { battery: 1 }, time: 10 },
        { inputs: { steel: 3, circuit: 1 }, output: { engine_part: 1 }, time: 15 }
    ],
    fuel_refinery: [
        { inputs: { dark_matter: 2, quantum_ore: 1, coal: 5 }, output: { super_fuel: 1 }, time: 30 }
    ]
};

// ==================== MACHINE TYPES ====================
const MACHINES = {
    miner: {
        name: 'Miner',
        icon: '‚õè',
        color: '#886644',
        cost: { iron_ingot: 3, copper_ingot: 2 },
        buyPrice: 50,
        power: -2,
        heat: 0,
        size: 1,
        description: 'Extracts resources from nodes'
    },
    water_miner: {
        name: 'Water Miner',
        icon: 'üöø',
        color: '#446688',
        cost: { iron_ingot: 5, copper_ingot: 3 },
        buyPrice: 80,
        power: -3,
        heat: 0,
        size: 1,
        description: 'Drills ice for water'
    },
    furnace: {
        name: 'Furnace',
        icon: 'üî•',
        color: '#884422',
        cost: { iron_ingot: 5, coal: 3 },
        buyPrice: 80,
        power: -4,
        heat: 5,
        size: 1,
        description: 'Smelts ore into ingots'
    },
    assembler: {
        name: 'Assembler',
        icon: '‚öô',
        color: '#448844',
        cost: { steel: 5, circuit: 2 },
        buyPrice: 150,
        power: -5,
        heat: 2,
        size: 1,
        description: 'Crafts advanced parts'
    },
    solar_panel: {
        name: 'Solar Panel',
        icon: '‚òÄ',
        color: '#4488cc',
        cost: { copper_ingot: 3, crystal: 1 },
        buyPrice: 100,
        power: 10,
        heat: 0,
        size: 1,
        description: 'Generates power during day'
    },
    generator: {
        name: 'Generator',
        icon: '‚ö°',
        color: '#888844',
        cost: { steel: 3, copper_ingot: 2 },
        buyPrice: 120,
        power: 15,
        heat: 8,
        size: 1,
        description: 'Burns fuel for power'
    },
    battery: {
        name: 'Battery',
        icon: 'üîã',
        color: '#44aa44',
        cost: { copper_ingot: 2, iron_ingot: 2 },
        buyPrice: 60,
        power: 0,
        heat: 0,
        size: 1,
        capacity: 100,
        description: 'Stores excess power'
    },
    heater: {
        name: 'Heater',
        icon: '‚ô®',
        color: '#cc4422',
        cost: { iron_ingot: 3, copper_ingot: 2 },
        buyPrice: 40,
        power: -3,
        heat: 20,
        fireRisk: true,
        size: 1,
        description: 'Warms nearby machines. Fire risk!'
    },
    heat_lamp: {
        name: 'Heat Lamp',
        icon: 'üí°',
        color: '#ccaa44',
        cost: { copper_ingot: 2, iron_ingot: 1 },
        buyPrice: 30,
        power: -1,
        heat: 8,
        size: 1,
        description: 'Weak but safe heat source'
    },
    heat_sink: {
        name: 'Heat Sink',
        icon: '‚âã',
        color: '#666688',
        cost: { copper_ingot: 4, iron_ingot: 2 },
        buyPrice: 50,
        power: 0,
        heat: -10,
        size: 1,
        description: 'Absorbs excess heat'
    },
    fan: {
        name: 'Fan',
        icon: '‚ùä',
        color: '#88aacc',
        cost: { iron_ingot: 2, copper_ingot: 2 },
        buyPrice: 45,
        power: -2,
        heat: -15,
        size: 1,
        description: 'Active cooling'
    },
    conveyor: {
        name: 'Conveyor',
        icon: '‚Üí',
        color: '#666666',
        cost: { iron_ingot: 1, copper_ingot: 1 },
        buyPrice: 15,
        power: -0.5,
        heat: 0,
        size: 1,
        description: 'Moves items between machines'
    },
    pipe: {
        name: 'Pipe',
        icon: '‚ïê',
        color: '#445566',
        cost: { iron_ingot: 2 },
        buyPrice: 10,
        power: 0,
        heat: 0,
        size: 1,
        description: 'Moves liquids/snow'
    },
    storage: {
        name: 'Storage Crate',
        icon: 'üì¶',
        color: '#886644',
        cost: { iron_ingot: 4 },
        buyPrice: 25,
        power: 0,
        heat: 0,
        size: 1,
        capacity: 32,
        description: 'Stores items'
    },
    extinguisher: {
        name: 'Fire Extinguisher',
        icon: 'üßØ',
        color: '#cc2222',
        cost: { steel: 3, copper_ingot: 2 },
        buyPrice: 75,
        power: -1,
        heat: 0,
        range: 5,
        size: 1,
        description: 'Auto-suppresses fires'
    },
    light: {
        name: 'Light',
        icon: '‚ú¶',
        color: '#ffffaa',
        cost: { copper_ingot: 1, iron_ingot: 1 },
        buyPrice: 20,
        power: -0.5,
        heat: 1,
        size: 1,
        description: 'Illuminates area at night'
    },
    landing_pad: {
        name: 'Landing Pad',
        icon: 'üöÄ',
        color: '#666688',
        cost: { steel: 10, circuit: 5 },
        buyPrice: 500,
        power: -5,
        heat: 0,
        size: 2,
        description: 'Travel between planets'
    },
    repair_robot: {
        name: 'Repair Robot',
        icon: 'ü§ñ',
        color: '#88aa88',
        cost: { steel: 4, circuit: 2 },
        buyPrice: 200,
        power: -2,
        heat: 0,
        size: 1,
        description: 'Auto-repairs damaged machines'
    },
    battery_bank: {
        name: 'Battery Bank',
        icon: 'üîå',
        color: '#44aa66',
        cost: { steel: 5, copper_ingot: 4, circuit: 2 },
        buyPrice: 180,
        power: 0,
        heat: 0,
        size: 1,
        capacity: 500,
        description: 'Stores batteries, Sun Trackers deposit here'
    },
    sun_tracker: {
        name: 'Sun Tracker',
        icon: '‚òÄÔ∏è',
        color: '#ffcc44',
        cost: { steel: 5, circuit: 3, solar_panel_item: 2 },
        buyPrice: 300,
        power: 0,
        heat: 0,
        size: 1,
        description: 'Autonomous robot that collects solar power'
    },
    fuel_refinery: {
        name: 'Fuel Refinery',
        icon: '‚öó',
        color: '#884488',
        cost: { steel: 8, circuit: 4, engine_part: 2 },
        buyPrice: 400,
        power: -8,
        heat: 10,
        size: 1,
        description: 'Creates super fuel for planet travel'
    },
    cable_tool: {
        name: 'Cable Tool',
        icon: '‚ö°',
        color: '#ffcc00',
        cost: { cable: 1 },
        buyPrice: 0,
        power: 0,
        heat: 0,
        size: 0,
        isTool: true,
        description: 'Click two machines to connect them with a power cable'
    }
};

// ==================== CANVAS SETUP ====================
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const minimapCanvas = document.getElementById('minimapCanvas');
const minimapCtx = minimapCanvas.getContext('2d');

function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    minimapCanvas.width = 150;
    minimapCanvas.height = 150;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// ==================== SPRITE SYSTEM ====================
const spriteCache = {};
let animationFrame = 0;

// Create offscreen canvas for sprite generation
function createSprite(width, height, drawFunc) {
    const key = drawFunc.toString();
    if (spriteCache[key]) return spriteCache[key];

    const offscreen = document.createElement('canvas');
    offscreen.width = width;
    offscreen.height = height;
    const offCtx = offscreen.getContext('2d');
    drawFunc(offCtx, width, height);
    spriteCache[key] = offscreen;
    return offscreen;
}

// ==================== ISOMETRIC SPRITE HELPERS ====================
// Draw an isometric cube/box
function isoCube(ctx, cx, cy, w, h, d, topCol, leftCol, rightCol) {
    // Top face (diamond)
    ctx.fillStyle = topCol;
    ctx.beginPath();
    ctx.moveTo(cx, cy - h);
    ctx.lineTo(cx + w, cy - h + w/2);
    ctx.lineTo(cx, cy - h + w);
    ctx.lineTo(cx - w, cy - h + w/2);
    ctx.closePath();
    ctx.fill();

    // Left face
    ctx.fillStyle = leftCol;
    ctx.beginPath();
    ctx.moveTo(cx - w, cy - h + w/2);
    ctx.lineTo(cx, cy - h + w);
    ctx.lineTo(cx, cy + d);
    ctx.lineTo(cx - w, cy + d - w/2);
    ctx.closePath();
    ctx.fill();

    // Right face
    ctx.fillStyle = rightCol;
    ctx.beginPath();
    ctx.moveTo(cx + w, cy - h + w/2);
    ctx.lineTo(cx, cy - h + w);
    ctx.lineTo(cx, cy + d);
    ctx.lineTo(cx + w, cy + d - w/2);
    ctx.closePath();
    ctx.fill();
}

// Draw isometric flat top surface (diamond)
function isoTop(ctx, cx, cy, w, color) {
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(cx, cy - w/2);
    ctx.lineTo(cx + w, cy);
    ctx.lineTo(cx, cy + w/2);
    ctx.lineTo(cx - w, cy);
    ctx.closePath();
    ctx.fill();
}

// Draw isometric cylinder
function isoCylinder(ctx, cx, cy, r, h, topCol, sideCol) {
    // Side
    ctx.fillStyle = sideCol;
    ctx.beginPath();
    ctx.ellipse(cx, cy, r, r/2, 0, 0, Math.PI);
    ctx.lineTo(cx - r, cy - h);
    ctx.ellipse(cx, cy - h, r, r/2, 0, Math.PI, 0, true);
    ctx.closePath();
    ctx.fill();

    // Top ellipse
    ctx.fillStyle = topCol;
    ctx.beginPath();
    ctx.ellipse(cx, cy - h, r, r/2, 0, 0, Math.PI * 2);
    ctx.fill();
}

// ==================== MACHINE SPRITES ====================
const SPRITES = {
    // Solar Panel - tilted panel on stand
    solar_panel: (ctx, w, h, frame, isDay) => {
        const cx = 64, cy = 96;

        // Ground base (concrete pad)
        isoTop(ctx, cx, cy + 10, 18, '#555566');
        isoTop(ctx, cx, cy + 8, 16, '#666677');

        // Central support pillar
        isoCube(ctx, cx, cy + 4, 3, 0, 14, '#778899', '#667788', '#889aaa');

        // Pivot joint (ball)
        ctx.fillStyle = '#889aaa';
        ctx.beginPath();
        ctx.arc(cx, cy - 6, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#667788';
        ctx.beginPath();
        ctx.arc(cx - 1, cy - 7, 2, 0, Math.PI * 2);
        ctx.fill();

        // Panel frame - tilted isometric rectangle facing up-right
        // Back edge of frame (silver/aluminum)
        ctx.fillStyle = '#aabbcc';
        ctx.beginPath();
        ctx.moveTo(cx - 24, cy - 6);
        ctx.lineTo(cx + 24, cy - 18);
        ctx.lineTo(cx + 24, cy - 21);
        ctx.lineTo(cx - 24, cy - 9);
        ctx.closePath();
        ctx.fill();

        // Panel surface (dark blue base)
        const dayBrightness = isDay ? 1 : 0.4;
        ctx.fillStyle = isDay ? '#1a3366' : '#0d1a33';
        ctx.beginPath();
        ctx.moveTo(cx - 24, cy - 6);
        ctx.lineTo(cx + 24, cy - 18);
        ctx.lineTo(cx + 20, cy - 34);
        ctx.lineTo(cx - 28, cy - 22);
        ctx.closePath();
        ctx.fill();

        // Draw solar cells in a 4x3 grid
        const cellRows = 3;
        const cellCols = 4;
        for (let row = 0; row < cellRows; row++) {
            for (let col = 0; col < cellCols; col++) {
                // Calculate cell position with perspective
                const cellW = 11;
                const cellH = 4;
                const baseX = cx - 22 + col * cellW;
                const baseY = cy - 8 - row * cellH - col * 2.5;

                // Cell color with slight variation
                const shimmer = isDay ? Math.sin(frame * 0.15 + row + col) * 15 : 0;
                const r = Math.floor((30 + shimmer) * dayBrightness);
                const g = Math.floor((80 + shimmer) * dayBrightness);
                const b = Math.floor((160 + shimmer * 1.5) * dayBrightness);
                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;

                // Draw cell as small parallelogram
                ctx.beginPath();
                ctx.moveTo(baseX, baseY);
                ctx.lineTo(baseX + cellW - 1, baseY - 2.5);
                ctx.lineTo(baseX + cellW - 2, baseY - cellH - 1.5);
                ctx.lineTo(baseX - 1, baseY - cellH + 1);
                ctx.closePath();
                ctx.fill();

                // Cell highlight (top-left)
                if (isDay) {
                    ctx.fillStyle = `rgba(100, 150, 255, ${0.2 + shimmer * 0.01})`;
                    ctx.beginPath();
                    ctx.moveTo(baseX, baseY);
                    ctx.lineTo(baseX + 3, baseY - 0.8);
                    ctx.lineTo(baseX + 2, baseY - 2);
                    ctx.lineTo(baseX - 1, baseY - 1.2);
                    ctx.closePath();
                    ctx.fill();
                }
            }
        }

        // Grid lines between cells (silver)
        ctx.strokeStyle = '#8899aa';
        ctx.lineWidth = 1;
        // Vertical dividers
        for (let col = 1; col < cellCols; col++) {
            const x = cx - 22 + col * 11;
            ctx.beginPath();
            ctx.moveTo(x, cy - 7 - col * 2.5);
            ctx.lineTo(x - 4, cy - 21 - col * 2.5);
            ctx.stroke();
        }
        // Horizontal dividers
        for (let row = 1; row < cellRows; row++) {
            ctx.beginPath();
            ctx.moveTo(cx - 23, cy - 8 - row * 4);
            ctx.lineTo(cx + 21, cy - 20 - row * 4);
            ctx.stroke();
        }

        // Frame edges (aluminum border)
        ctx.strokeStyle = '#99aabb';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(cx - 24, cy - 6);
        ctx.lineTo(cx + 24, cy - 18);
        ctx.lineTo(cx + 20, cy - 34);
        ctx.lineTo(cx - 28, cy - 22);
        ctx.closePath();
        ctx.stroke();

        // Animated sun reflection glint
        if (isDay) {
            const glintPos = (frame % 60) / 60;
            const glintX = cx - 20 + glintPos * 40;
            const glintY = cy - 28 + glintPos * 16;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.beginPath();
            ctx.moveTo(glintX, glintY);
            ctx.lineTo(glintX + 3, glintY - 1);
            ctx.lineTo(glintX + 2, glintY - 3);
            ctx.lineTo(glintX - 1, glintY - 2);
            ctx.closePath();
            ctx.fill();

            // Secondary smaller glint
            ctx.fillStyle = 'rgba(200, 230, 255, 0.4)';
            ctx.beginPath();
            ctx.arc(glintX + 8, glintY + 2, 2, 0, Math.PI * 2);
            ctx.fill();
        }

        // Power indicator LED
        ctx.fillStyle = isDay ? '#00ff44' : '#442200';
        ctx.beginPath();
        ctx.arc(cx + 22, cy - 16, 2, 0, Math.PI * 2);
        ctx.fill();
        if (isDay) {
            // LED glow
            ctx.fillStyle = 'rgba(0, 255, 68, 0.3)';
            ctx.beginPath();
            ctx.arc(cx + 22, cy - 16, 4, 0, Math.PI * 2);
            ctx.fill();
        }
    },

    // Miner - drilling machine (isometric)
    miner: (ctx, w, h, frame, active) => {
        const cx = 64, cy = 96;

        // Base platform
        isoCube(ctx, cx, cy, 16, 0, 8, '#886644', '#775533', '#997755');

        // Main body
        isoCube(ctx, cx, cy - 8, 12, 0, 16, '#aa8866', '#997755', '#bb9977');

        // Drill tower
        isoCube(ctx, cx, cy - 24, 6, 0, 12, '#888888', '#666666', '#999999');

        // Drill bit (rotating)
        const drillRot = active ? frame * 0.3 : 0;
        ctx.save();
        ctx.translate(cx, cy - 36);
        ctx.rotate(drillRot);
        ctx.fillStyle = '#777777';
        ctx.beginPath();
        ctx.moveTo(0, -12);
        ctx.lineTo(-4, 0);
        ctx.lineTo(4, 0);
        ctx.closePath();
        ctx.fill();
        // Drill spiral
        ctx.strokeStyle = active ? '#aaaaaa' : '#666666';
        ctx.lineWidth = 2;
        ctx.beginPath();
        for (let i = 0; i < 3; i++) {
            ctx.moveTo(-3 + i, -10 + i * 3);
            ctx.lineTo(3 - i, -8 + i * 3);
        }
        ctx.stroke();
        ctx.restore();

        // Status light
        ctx.fillStyle = active ? '#44ff44' : '#ff4444';
        ctx.beginPath();
        ctx.arc(cx + 8, cy - 16, 3, 0, Math.PI * 2);
        ctx.fill();

        // Sparks when active
        if (active && frame % 6 < 3) {
            ctx.fillStyle = '#ffaa00';
            ctx.fillRect(cx - 2 + (frame % 4), cy - 40, 2, 2);
        }
    },

    // Furnace - smelting with fire (isometric)
    furnace: (ctx, w, h, frame, active) => {
        const cx = 64, cy = 96;

        // Stone base
        isoCube(ctx, cx, cy, 18, 0, 20, '#776655', '#665544', '#887766');

        // Chimney
        isoCube(ctx, cx + 10, cy - 20, 5, 0, 24, '#665544', '#554433', '#776655');

        // Fire opening (dark hole on front)
        ctx.fillStyle = '#221111';
        ctx.beginPath();
        ctx.moveTo(cx - 8, cy);
        ctx.lineTo(cx + 8, cy);
        ctx.lineTo(cx + 8, cy - 10);
        ctx.lineTo(cx - 8, cy - 10);
        ctx.closePath();
        ctx.fill();

        // Fire inside when active
        if (active) {
            const fireColors = ['#ff4400', '#ff6600', '#ffaa00', '#ffcc00'];
            for (let i = 0; i < 5; i++) {
                const fx = cx - 5 + (i * 3);
                const fy = cy - 3 - Math.sin(frame * 0.5 + i) * 4;
                ctx.fillStyle = fireColors[(frame + i) % fireColors.length];
                ctx.beginPath();
                ctx.arc(fx, fy, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Smoke when active
        if (active) {
            ctx.fillStyle = 'rgba(100,100,100,0.5)';
            for (let i = 0; i < 3; i++) {
                const sy = cy - 44 - ((frame * 2 + i * 8) % 20);
                const sx = cx + 10 + Math.sin(frame * 0.1 + i) * 3;
                ctx.beginPath();
                ctx.arc(sx, sy, 3 + i, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    },

    // Heater - glowing heating element (isometric)
    heater: (ctx, w, h, frame, active, overheated) => {
        const cx = 64, cy = 96;

        // Metal casing
        isoCube(ctx, cx, cy, 14, 0, 22, '#555566', '#444455', '#666677');

        // Vents on front
        ctx.fillStyle = '#333344';
        for (let i = 0; i < 4; i++) {
            ctx.fillRect(cx - 10, cy - 4 - i * 5, 20, 2);
        }

        // Heating coils glow
        if (active) {
            const glowIntensity = overheated ? 1 : 0.5 + Math.sin(frame * 0.2) * 0.3;
            const r = overheated ? 255 : 200;
            const g = overheated ? 100 + (frame % 50) : 80;
            ctx.fillStyle = `rgba(${r}, ${g}, 0, ${glowIntensity})`;
            ctx.fillRect(cx - 8, cy - 18, 16, 12);

            // Heat waves rising
            ctx.strokeStyle = `rgba(255, 100, 0, ${0.3 + Math.sin(frame * 0.3) * 0.2})`;
            ctx.lineWidth = 2;
            for (let i = 0; i < 3; i++) {
                const wy = cy - 24 - ((frame + i * 10) % 15);
                ctx.beginPath();
                ctx.moveTo(cx - 6 + i * 6, wy);
                ctx.quadraticCurveTo(cx - 3 + i * 6, wy - 4, cx - 6 + i * 6, wy - 8);
                ctx.stroke();
            }
        }
    },

    // Battery - power storage (isometric)
    battery: (ctx, w, h, frame, chargePercent) => {
        const cx = 64, cy = 96;
        const charge = chargePercent || 50;

        // Main battery body
        isoCube(ctx, cx, cy, 10, 0, 28, '#334433', '#223322', '#445544');

        // Terminal on top
        isoCube(ctx, cx, cy - 28, 5, 0, 4, '#666666', '#555555', '#777777');

        // Charge level indicator (on front face)
        const chargeHeight = Math.floor((charge / 100) * 20);
        const chargeColor = charge > 50 ? '#44ff44' : charge > 25 ? '#ffff44' : '#ff4444';
        ctx.fillStyle = chargeColor;
        ctx.fillRect(cx - 6, cy - chargeHeight, 12, chargeHeight);

        // Segment lines
        ctx.strokeStyle = '#223322';
        ctx.lineWidth = 1;
        for (let i = 1; i < 4; i++) {
            ctx.beginPath();
            ctx.moveTo(cx - 6, cy - i * 6);
            ctx.lineTo(cx + 6, cy - i * 6);
            ctx.stroke();
        }
    },

    // Conveyor belt - animated (isometric)
    conveyor: (ctx, w, h, frame, rotation) => {
        const cx = 64, cy = 96;
        const rot = rotation || 0;

        // Belt frame
        isoCube(ctx, cx, cy, 18, 0, 6, '#444455', '#333344', '#555566');

        // Belt surface (animated stripes)
        const offset = frame % 16;
        ctx.save();
        ctx.translate(cx, cy - 6);

        // Isometric belt top
        ctx.fillStyle = '#555555';
        ctx.beginPath();
        ctx.moveTo(0, -9);
        ctx.lineTo(18, 0);
        ctx.lineTo(0, 9);
        ctx.lineTo(-18, 0);
        ctx.closePath();
        ctx.fill();

        // Moving stripes
        ctx.strokeStyle = '#666666';
        ctx.lineWidth = 2;
        const dirs = [
            { dx: 1, dy: 0.5 },   // right
            { dx: -1, dy: 0.5 },  // down
            { dx: -1, dy: -0.5 }, // left
            { dx: 1, dy: -0.5 }   // up
        ];
        const dir = dirs[rot % 4];
        for (let i = -2; i < 3; i++) {
            const stripeOffset = (offset / 16) * 8;
            const x = i * 6 + (dir.dx * stripeOffset);
            const y = i * 3 + (dir.dy * stripeOffset);
            ctx.beginPath();
            ctx.moveTo(x - 4, y - 2);
            ctx.lineTo(x + 4, y + 2);
            ctx.stroke();
        }
        ctx.restore();

        // Direction arrow
        ctx.fillStyle = '#ffff00';
        const arrowDirs = [[10, 0], [0, 5], [-10, 0], [0, -5]];
        const ad = arrowDirs[rot % 4];
        ctx.beginPath();
        ctx.moveTo(cx, cy - 6);
        ctx.lineTo(cx + ad[0], cy - 6 + ad[1]);
        ctx.lineTo(cx + ad[0] * 0.5 - ad[1] * 0.3, cy - 6 + ad[1] * 0.5 + ad[0] * 0.3);
        ctx.closePath();
        ctx.fill();
    },

    // Storage crate (isometric)
    storage: (ctx, w, h, frame, fillPercent) => {
        const cx = 64, cy = 96;

        // Wooden crate body
        isoCube(ctx, cx, cy, 16, 0, 18, '#aa7744', '#886633', '#bb8855');

        // Wood grain lines on front
        ctx.strokeStyle = '#996633';
        ctx.lineWidth = 1;
        for (let i = 0; i < 3; i++) {
            ctx.beginPath();
            ctx.moveTo(cx - 12, cy - 4 - i * 5);
            ctx.lineTo(cx + 12, cy - 4 - i * 5);
            ctx.stroke();
        }

        // Metal corner brackets
        ctx.fillStyle = '#888888';
        ctx.fillRect(cx - 14, cy - 2, 4, 4);
        ctx.fillRect(cx + 10, cy - 2, 4, 4);
        ctx.fillRect(cx - 14, cy - 16, 4, 4);
        ctx.fillRect(cx + 10, cy - 16, 4, 4);

        // Items visible on top if filled
        if (fillPercent > 0) {
            const items = Math.min(4, Math.floor((fillPercent || 0) / 25) + 1);
            for (let i = 0; i < items; i++) {
                ctx.fillStyle = ['#ffcc44', '#44aaff', '#ff6644', '#44ff88'][i];
                const ix = cx - 8 + (i % 2) * 10;
                const iy = cy - 20 + Math.floor(i / 2) * 5;
                ctx.beginPath();
                ctx.arc(ix, iy, 4, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    },

    // Generator (isometric)
    generator: (ctx, w, h, frame, active) => {
        const cx = 64, cy = 96;

        // Main housing
        isoCube(ctx, cx, cy, 16, 0, 18, '#445566', '#334455', '#556677');

        // Engine block on top
        isoCube(ctx, cx - 4, cy - 18, 10, 0, 10, '#556677', '#445566', '#667788');

        // Exhaust pipe
        isoCylinder(ctx, cx + 12, cy - 18, 4, 16, '#444444', '#333333');

        // Exhaust smoke when active
        if (active) {
            ctx.fillStyle = 'rgba(100,100,100,0.4)';
            for (let i = 0; i < 3; i++) {
                const sy = cy - 34 - ((frame * 2 + i * 6) % 16);
                const sx = cx + 12 + Math.sin(frame * 0.1 + i) * 2;
                ctx.beginPath();
                ctx.arc(sx, sy, 3 + i, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Spinning flywheel visible through window
        if (active) {
            ctx.save();
            ctx.translate(cx, cy - 8);
            ctx.rotate(frame * 0.2);
            ctx.fillStyle = '#ffcc00';
            for (let i = 0; i < 4; i++) {
                ctx.rotate(Math.PI / 2);
                ctx.fillRect(-2, -6, 4, 6);
            }
            ctx.restore();
        }

        // Status light
        ctx.fillStyle = active ? '#44ff44' : '#ff4444';
        ctx.beginPath();
        ctx.arc(cx - 10, cy - 10, 3, 0, Math.PI * 2);
        ctx.fill();
    },

    // Robot player (isometric)
    robot: (ctx, w, h, frame, frozen, moving) => {
        const cx = 64, cy = 100;
        const bobY = moving ? Math.sin(frame * 0.5) * 2 : 0;
        const bodyColor = frozen ? '#88aacc' : '#55aa55';
        const darkBody = frozen ? '#6688aa' : '#448844';
        const lightBody = frozen ? '#aaccee' : '#66bb66';

        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath();
        ctx.ellipse(cx, cy + 4, 12, 6, 0, 0, Math.PI * 2);
        ctx.fill();

        // Legs (isometric)
        const legOffset = moving ? Math.sin(frame * 0.5) * 3 : 0;
        isoCube(ctx, cx - 6, cy + legOffset, 4, 0, 10, darkBody, darkBody, bodyColor);
        isoCube(ctx, cx + 6, cy - legOffset, 4, 0, 10, darkBody, darkBody, bodyColor);

        // Body (isometric box)
        isoCube(ctx, cx, cy - 10 + bobY, 10, 0, 14, lightBody, darkBody, bodyColor);

        // Chest panel
        ctx.fillStyle = frozen ? '#334455' : '#223322';
        ctx.fillRect(cx - 6, cy - 18 + bobY, 12, 8);

        // Chest lights
        ctx.fillStyle = frozen ? '#4488ff' : '#44ff44';
        ctx.beginPath();
        ctx.arc(cx - 3, cy - 14 + bobY, 2, 0, Math.PI * 2);
        ctx.arc(cx + 3, cy - 14 + bobY, 2, 0, Math.PI * 2);
        ctx.fill();

        // Head (isometric box)
        isoCube(ctx, cx, cy - 28 + bobY, 8, 0, 10, lightBody, darkBody, bodyColor);

        // Eyes
        ctx.fillStyle = frozen ? '#4488ff' : '#ffff44';
        ctx.fillRect(cx - 5, cy - 34 + bobY, 3, 3);
        ctx.fillRect(cx + 2, cy - 34 + bobY, 3, 3);

        // Antenna
        ctx.fillStyle = '#888888';
        ctx.fillRect(cx - 1, cy - 42 + bobY, 2, 6);
        ctx.fillStyle = frozen ? '#4488ff' : '#ff4444';
        ctx.beginPath();
        ctx.arc(cx, cy - 44 + bobY, 3, 0, Math.PI * 2);
        ctx.fill();

        // Arms
        const armSwing = moving ? Math.sin(frame * 0.5) * 4 : 0;
        isoCube(ctx, cx - 14, cy - 16 + bobY + armSwing, 3, 0, 10, bodyColor, darkBody, lightBody);
        isoCube(ctx, cx + 14, cy - 16 + bobY - armSwing, 3, 0, 10, bodyColor, darkBody, lightBody);

        // Ice crystals if frozen
        if (frozen) {
            ctx.fillStyle = '#aaddff';
            ctx.beginPath();
            ctx.moveTo(cx - 12, cy - 30 + bobY);
            ctx.lineTo(cx - 15, cy - 35 + bobY);
            ctx.lineTo(cx - 10, cy - 32 + bobY);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(cx + 10, cy - 20 + bobY);
            ctx.lineTo(cx + 15, cy - 24 + bobY);
            ctx.lineTo(cx + 12, cy - 18 + bobY);
            ctx.fill();
        }
    },

    // Fire effect (isometric)
    fire: (ctx, w, h, frame) => {
        const cx = 64, cy = 96;
        const fireColors = ['#ff2200', '#ff4400', '#ff6600', '#ff8800', '#ffaa00', '#ffcc00'];

        // Fire particles rising
        for (let i = 0; i < 8; i++) {
            const fx = cx + Math.sin(frame * 0.3 + i * 2) * 10;
            const fy = cy - 10 - ((frame * 3 + i * 8) % 30);
            const size = 6 - (i % 4);
            ctx.fillStyle = fireColors[(frame + i) % fireColors.length];
            ctx.beginPath();
            ctx.arc(fx, fy, size, 0, Math.PI * 2);
            ctx.fill();
        }

        // Fire base (isometric)
        ctx.fillStyle = '#ffcc00';
        ctx.beginPath();
        ctx.ellipse(cx, cy, 12, 6, 0, 0, Math.PI * 2);
        ctx.fill();
    },

    // Light (isometric)
    light: (ctx, w, h, frame, active) => {
        const cx = 64, cy = 96;

        // Base
        isoTop(ctx, cx, cy + 4, 10, '#444455');

        // Post
        isoCube(ctx, cx, cy, 3, 0, 24, '#666666', '#555555', '#777777');

        // Lamp housing
        isoCube(ctx, cx, cy - 28, 10, 0, 8, '#555566', '#444455', '#666677');

        // Light glow
        if (active) {
            const glow = 0.6 + Math.sin(frame * 0.1) * 0.2;
            ctx.fillStyle = `rgba(255, 255, 200, ${glow})`;
            ctx.beginPath();
            ctx.arc(cx, cy - 32, 10, 0, Math.PI * 2);
            ctx.fill();

            // Light cone below
            ctx.fillStyle = 'rgba(255, 255, 200, 0.2)';
            ctx.beginPath();
            ctx.moveTo(cx - 8, cy - 28);
            ctx.lineTo(cx + 8, cy - 28);
            ctx.lineTo(cx + 16, cy + 4);
            ctx.lineTo(cx - 16, cy + 4);
            ctx.closePath();
            ctx.fill();
        }
    },

    // Landing pad (isometric)
    landing_pad: (ctx, w, h, frame, active) => {
        const cx = 64, cy = 96;

        // Main platform (flat isometric)
        isoTop(ctx, cx, cy, 24, '#555566');

        // Raised edge
        isoCube(ctx, cx, cy, 24, 0, 4, '#666677', '#555566', '#777788');

        // Warning stripes on edge
        ctx.strokeStyle = '#ffcc00';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(cx - 20, cy);
        ctx.lineTo(cx, cy - 10);
        ctx.lineTo(cx + 20, cy);
        ctx.lineTo(cx, cy + 10);
        ctx.closePath();
        ctx.stroke();

        // H marking
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(cx - 8, cy - 4, 3, 8);
        ctx.fillRect(cx + 5, cy - 4, 3, 8);
        ctx.fillRect(cx - 5, cy - 1, 10, 2);

        // Landing lights
        if (active) {
            const blink = (frame % 20) < 10;
            const colors = [
                { x: cx - 18, y: cy, on: '#ff0000', off: '#440000' },
                { x: cx + 18, y: cy, on: '#ff0000', off: '#440000' },
                { x: cx, y: cy - 8, on: '#00ff00', off: '#004400' },
                { x: cx, y: cy + 8, on: '#00ff00', off: '#004400' }
            ];
            colors.forEach(light => {
                ctx.fillStyle = blink ? light.on : light.off;
                ctx.beginPath();
                ctx.arc(light.x, light.y, 3, 0, Math.PI * 2);
                ctx.fill();
            });
        }
    },

    // Extinguisher station (isometric)
    extinguisher: (ctx, w, h, frame, active) => {
        const cx = 64, cy = 96;

        // Red cabinet
        isoCube(ctx, cx, cy, 12, 0, 24, '#dd3333', '#aa1111', '#ee4444');

        // Glass window on front
        ctx.fillStyle = 'rgba(200,230,255,0.5)';
        ctx.fillRect(cx - 8, cy - 18, 16, 12);

        // Extinguisher inside (red cylinder)
        isoCylinder(ctx, cx, cy - 6, 4, 12, '#ff0000', '#cc0000');

        // Spray effect when active
        if (active) {
            ctx.fillStyle = 'rgba(255,255,255,0.6)';
            for (let i = 0; i < 10; i++) {
                const angle = (frame * 0.2 + i * 0.6);
                const dist = 10 + (frame % 10) + i * 2;
                const sx = cx + Math.cos(angle) * dist;
                const sy = cy - 10 + Math.sin(angle) * dist * 0.5;
                ctx.beginPath();
                ctx.arc(sx, sy, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    },

    // Heat sink (isometric)
    heat_sink: (ctx, w, h, frame) => {
        const cx = 64, cy = 96;

        // Base plate
        isoCube(ctx, cx, cy, 18, 0, 4, '#556677', '#445566', '#667788');

        // Cooling fins (multiple thin boxes)
        for (let i = 0; i < 5; i++) {
            const finX = cx - 12 + i * 6;
            const finY = cy - 4 + i * 1.5 - 3;
            isoCube(ctx, finX, finY, 2, 0, 16, '#8899bb', '#6677aa', '#99aacc');
        }
    },

    // Fan (isometric)
    fan: (ctx, w, h, frame, active) => {
        const cx = 64, cy = 96;

        // Base/housing (isometric cylinder shape)
        isoCube(ctx, cx, cy, 14, 0, 6, '#555566', '#444455', '#666677');

        // Fan cage (circular on top)
        ctx.strokeStyle = '#667788';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.ellipse(cx, cy - 6, 14, 7, 0, 0, Math.PI * 2);
        ctx.stroke();

        // Inner dark area
        ctx.fillStyle = '#222233';
        ctx.beginPath();
        ctx.ellipse(cx, cy - 6, 12, 6, 0, 0, Math.PI * 2);
        ctx.fill();

        // Spinning blades
        const rotation = active ? frame * 0.4 : 0;
        ctx.save();
        ctx.translate(cx, cy - 6);
        for (let i = 0; i < 4; i++) {
            const angle = rotation + (i * Math.PI / 2);
            ctx.fillStyle = '#778899';
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(Math.cos(angle) * 10, Math.sin(angle) * 5);
            ctx.lineTo(Math.cos(angle + 0.3) * 8, Math.sin(angle + 0.3) * 4);
            ctx.closePath();
            ctx.fill();
        }
        ctx.restore();

        // Center hub
        ctx.fillStyle = '#888899';
        ctx.beginPath();
        ctx.ellipse(cx, cy - 6, 3, 1.5, 0, 0, Math.PI * 2);
        ctx.fill();
    },

    // Sun tracker robot (isometric)
    sun_tracker: (ctx, w, h, frame, state, charge) => {
        const cx = 64, cy = 96;

        // Wheels (4 small cylinders)
        isoCylinder(ctx, cx - 10, cy + 4, 4, 4, '#444444', '#333333');
        isoCylinder(ctx, cx + 10, cy + 4, 4, 4, '#444444', '#333333');
        isoCylinder(ctx, cx - 10, cy - 4, 4, 4, '#444444', '#333333');
        isoCylinder(ctx, cx + 10, cy - 4, 4, 4, '#444444', '#333333');

        // Body
        isoCube(ctx, cx, cy, 12, 0, 10, '#ffcc44', '#ddaa22', '#ffdd66');

        // Solar panel on arm (tilts to track sun)
        const tilt = Math.sin(frame * 0.05) * 5;
        ctx.fillStyle = '#4488cc';
        ctx.beginPath();
        ctx.moveTo(cx - 16, cy - 14 + tilt);
        ctx.lineTo(cx + 16, cy - 14 - tilt);
        ctx.lineTo(cx + 14, cy - 20 - tilt);
        ctx.lineTo(cx - 14, cy - 20 + tilt);
        ctx.closePath();
        ctx.fill();

        // Panel frame
        ctx.strokeStyle = '#336699';
        ctx.lineWidth = 1;
        ctx.stroke();

        // Charge bar
        const chargeWidth = Math.floor(((charge || 0) / 100) * 16);
        ctx.fillStyle = '#223322';
        ctx.fillRect(cx - 8, cy - 4, 16, 4);
        ctx.fillStyle = '#44ff44';
        ctx.fillRect(cx - 8, cy - 4, chargeWidth, 4);

        // State indicator
        const stateColor = state === 'collecting' ? '#ffff00' :
                          state === 'returning' ? '#ff8800' : '#888888';
        ctx.fillStyle = stateColor;
        ctx.beginPath();
        ctx.arc(cx, cy - 8, 3, 0, Math.PI * 2);
        ctx.fill();
    },

    // Water miner (isometric)
    water_miner: (ctx, w, h, frame, active) => {
        const cx = 64, cy = 96;

        // Ice platform
        isoTop(ctx, cx, cy + 4, 18, '#88ccee');
        ctx.fillStyle = '#aaddff';
        ctx.beginPath();
        ctx.moveTo(cx - 12, cy + 2);
        ctx.lineTo(cx, cy + 8);
        ctx.lineTo(cx + 12, cy + 2);
        ctx.lineTo(cx, cy - 4);
        ctx.closePath();
        ctx.fill();

        // Main body
        isoCube(ctx, cx, cy, 14, 0, 16, '#5588aa', '#447799', '#66aacc');

        // Drill tower
        isoCube(ctx, cx, cy - 16, 5, 0, 14, '#778899', '#667788', '#889aaa');

        // Drill bit (rotating)
        const drillRot = active ? frame * 0.3 : 0;
        ctx.save();
        ctx.translate(cx, cy - 30);
        ctx.rotate(drillRot);
        ctx.fillStyle = '#667788';
        ctx.beginPath();
        ctx.moveTo(0, -10);
        ctx.lineTo(-3, 0);
        ctx.lineTo(3, 0);
        ctx.closePath();
        ctx.fill();
        ctx.restore();

        // Water tank (cylinder on side)
        isoCylinder(ctx, cx + 12, cy - 4, 5, 12, '#3366aa', '#224488');

        // Water level
        if (active) {
            const waterLevel = 4 + (frame % 6);
            ctx.fillStyle = '#4488cc';
            ctx.beginPath();
            ctx.ellipse(cx + 12, cy - 4 - waterLevel, 4, 2, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        // Status light
        ctx.fillStyle = active ? '#44ffff' : '#4444aa';
        ctx.beginPath();
        ctx.arc(cx - 10, cy - 10, 3, 0, Math.PI * 2);
        ctx.fill();
    },

    // Assembler (isometric)
    assembler: (ctx, w, h, frame, active) => {
        const cx = 64, cy = 96;

        // Base platform
        isoCube(ctx, cx, cy, 20, 0, 6, '#445566', '#334455', '#556677');

        // Main body
        isoCube(ctx, cx, cy - 6, 16, 0, 18, '#556677', '#445566', '#667788');

        // Display screen
        ctx.fillStyle = active ? '#003322' : '#111122';
        ctx.fillRect(cx - 10, cy - 20, 20, 10);

        // Screen content when active
        if (active) {
            ctx.fillStyle = '#00ff88';
            const blink = (frame % 20) < 10;
            if (blink) ctx.fillRect(cx - 6, cy - 18, 3, 2);
            ctx.fillRect(cx - 1, cy - 16, 3, 2);
            if (blink) ctx.fillRect(cx + 4, cy - 18, 3, 2);
        }

        // Robotic arm
        const armAngle = active ? Math.sin(frame * 0.15) * 0.3 : 0;
        ctx.save();
        ctx.translate(cx, cy - 6);
        ctx.rotate(armAngle);
        ctx.fillStyle = '#888899';
        ctx.fillRect(-2, 0, 4, 14);
        // Claw
        ctx.fillRect(-5, 12, 4, 3);
        ctx.fillRect(1, 12, 4, 3);
        ctx.restore();

        // Input/output ports
        ctx.fillStyle = '#333344';
        ctx.fillRect(cx - 18, cy - 12, 4, 6);
        ctx.fillRect(cx + 14, cy - 12, 4, 6);
    },

    // Heat lamp (isometric)
    heat_lamp: (ctx, w, h, frame, active) => {
        const cx = 64, cy = 96;

        // Base
        isoTop(ctx, cx, cy + 4, 10, '#444455');

        // Stand
        isoCube(ctx, cx, cy, 3, 0, 20, '#666666', '#555555', '#777777');

        // Lamp shade (cone shape)
        ctx.fillStyle = '#cc8844';
        ctx.beginPath();
        ctx.moveTo(cx - 14, cy - 20);
        ctx.lineTo(cx + 14, cy - 20);
        ctx.lineTo(cx + 6, cy - 30);
        ctx.lineTo(cx - 6, cy - 30);
        ctx.closePath();
        ctx.fill();

        // Shade depth
        ctx.fillStyle = '#aa6622';
        ctx.beginPath();
        ctx.moveTo(cx - 14, cy - 20);
        ctx.lineTo(cx - 6, cy - 30);
        ctx.lineTo(cx - 6, cy - 28);
        ctx.lineTo(cx - 12, cy - 20);
        ctx.closePath();
        ctx.fill();

        // Bulb glow when active
        if (active) {
            const glow = 0.5 + Math.sin(frame * 0.15) * 0.2;
            ctx.fillStyle = `rgba(255, 200, 100, ${glow})`;
            ctx.beginPath();
            ctx.arc(cx, cy - 24, 8, 0, Math.PI * 2);
            ctx.fill();

            // Heat cone
            ctx.fillStyle = 'rgba(255, 150, 50, 0.15)';
            ctx.beginPath();
            ctx.moveTo(cx - 10, cy - 20);
            ctx.lineTo(cx + 10, cy - 20);
            ctx.lineTo(cx + 18, cy + 4);
            ctx.lineTo(cx - 18, cy + 4);
            ctx.closePath();
            ctx.fill();
        }
    },

    // Pipe (isometric)
    pipe: (ctx, w, h, frame, rotation, active) => {
        const cx = 64, cy = 96;
        const rot = rotation || 0;
        const isHorizontal = (rot % 2) === 0;

        if (isHorizontal) {
            // Horizontal pipe (isometric tube)
            ctx.fillStyle = '#556677';
            ctx.beginPath();
            ctx.ellipse(cx - 20, cy, 4, 8, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#667788';
            ctx.fillRect(cx - 20, cy - 8, 40, 16);

            ctx.fillStyle = '#556677';
            ctx.beginPath();
            ctx.ellipse(cx + 20, cy, 4, 8, 0, 0, Math.PI * 2);
            ctx.fill();

            // Flow
            if (active) {
                ctx.fillStyle = '#4488cc';
                const flowOffset = (frame * 3) % 40;
                for (let i = 0; i < 4; i++) {
                    const fx = cx - 18 + ((flowOffset + i * 10) % 40);
                    ctx.beginPath();
                    ctx.ellipse(fx, cy, 2, 4, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        } else {
            // Vertical pipe (isometric)
            isoCylinder(ctx, cx, cy + 8, 6, 32, '#667788', '#556677');

            // Flow
            if (active) {
                ctx.fillStyle = '#4488cc';
                const flowOffset = (frame * 3) % 30;
                for (let i = 0; i < 3; i++) {
                    const fy = cy + 6 - ((flowOffset + i * 10) % 30);
                    ctx.beginPath();
                    ctx.ellipse(cx, fy, 3, 1.5, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
    },

    // Repair robot (isometric)
    repair_robot: (ctx, w, h, frame, active) => {
        const cx = 64, cy = 96;

        // Treads (animated)
        const treadAnim = active ? frame : 0;
        ctx.fillStyle = '#333333';
        for (let i = 0; i < 4; i++) {
            const ty = ((treadAnim + i * 3) % 12) - 6;
            ctx.fillRect(cx - 16, cy + ty - 1, 6, 3);
            ctx.fillRect(cx + 10, cy + ty - 1, 6, 3);
        }

        // Tread housings
        isoCube(ctx, cx - 12, cy, 5, 0, 10, '#444444', '#333333', '#555555');
        isoCube(ctx, cx + 12, cy, 5, 0, 10, '#444444', '#333333', '#555555');

        // Body
        isoCube(ctx, cx, cy - 4, 10, 0, 12, '#ff8844', '#dd6622', '#ffaa66');

        // Sensor dome
        isoCylinder(ctx, cx, cy - 20, 6, 6, '#aabbcc', '#8899aa');

        // Tool arm
        const armExtend = active ? Math.sin(frame * 0.2) * 6 : 0;
        ctx.fillStyle = '#888888';
        ctx.fillRect(cx + 10, cy - 10 + armExtend * 0.3, 12 + armExtend, 4);

        // Wrench
        ctx.fillStyle = '#777777';
        ctx.fillRect(cx + 20 + armExtend, cy - 14 + armExtend * 0.3, 4, 3);
        ctx.fillRect(cx + 20 + armExtend, cy - 6 + armExtend * 0.3, 4, 3);

        // Status light
        ctx.fillStyle = active ? '#44ff44' : '#ffaa00';
        ctx.beginPath();
        ctx.arc(cx, cy - 18, 3, 0, Math.PI * 2);
        ctx.fill();
    },

    // Battery bank (isometric)
    battery_bank: (ctx, w, h, frame, charge) => {
        const cx = 64, cy = 96;

        // Rack frame
        isoCube(ctx, cx, cy, 22, 0, 24, '#444455', '#333344', '#555566');

        // Three batteries inside
        for (let i = 0; i < 3; i++) {
            const bx = cx - 12 + i * 12;
            const by = cy - 2 + (i - 1) * 3;

            // Battery
            isoCube(ctx, bx, by, 4, 0, 18, '#445544', '#334433', '#556655');

            // Charge level
            const slotCharge = Math.min(100, Math.max(0, (charge || 50) - i * 20) * 1.5);
            const chargeHeight = Math.floor((slotCharge / 100) * 14);
            const chargeColor = slotCharge > 50 ? '#44ff44' : slotCharge > 25 ? '#ffff44' : '#ff4444';

            ctx.fillStyle = chargeColor;
            ctx.fillRect(bx - 2, by - chargeHeight, 4, chargeHeight);

            // Terminal
            ctx.fillStyle = '#666666';
            ctx.fillRect(bx - 1, by - 18, 2, 2);
        }

        // Connection cables
        ctx.strokeStyle = '#cc8844';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(cx - 12, cy - 10);
        ctx.lineTo(cx, cy - 8);
        ctx.lineTo(cx + 12, cy - 6);
        ctx.stroke();
    },

    // Fuel refinery (isometric)
    fuel_refinery: (ctx, w, h, frame, active) => {
        const cx = 64, cy = 96;

        // Base platform
        isoCube(ctx, cx, cy, 22, 0, 4, '#445555', '#334444', '#556666');

        // Main tank (large cylinder)
        isoCylinder(ctx, cx - 6, cy - 4, 10, 24, '#556666', '#445555');

        // Tank bands
        ctx.strokeStyle = '#667777';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.ellipse(cx - 6, cy - 10, 10, 5, 0, 0, Math.PI * 2);
        ctx.ellipse(cx - 6, cy - 18, 10, 5, 0, 0, Math.PI * 2);
        ctx.stroke();

        // Processing column
        isoCube(ctx, cx + 12, cy - 4, 6, 0, 28, '#445566', '#334455', '#556677');

        // Pipes connecting
        ctx.fillStyle = '#556677';
        ctx.fillRect(cx + 2, cy - 14, 8, 3);
        ctx.fillRect(cx + 2, cy - 22, 8, 3);

        // Bubbles when active
        if (active) {
            ctx.fillStyle = '#ff88ff';
            for (let i = 0; i < 4; i++) {
                const by = cy - 8 - ((frame * 2 + i * 6) % 18);
                const bx = cx - 8 + (i % 2) * 4 + Math.sin(frame * 0.2 + i) * 2;
                ctx.beginPath();
                ctx.arc(bx, by, 2, 0, Math.PI * 2);
                ctx.fill();
            }

            // Glow at top
            const glow = (frame % 15) < 8;
            ctx.fillStyle = glow ? '#ff00ff' : '#880088';
            ctx.beginPath();
            ctx.arc(cx + 12, cy - 34, 4, 0, Math.PI * 2);
            ctx.fill();
        }

        // Warning stripes
        ctx.fillStyle = '#ffaa00';
        for (let i = 0; i < 3; i++) {
            ctx.fillRect(cx - 18, cy - 8 - i * 8, 3, 4);
        }
    }
};

// Draw a sprite
function drawSprite(type, x, y, options = {}) {
    const spriteFunc = SPRITES[type];
    if (!spriteFunc) return;

    const size = 128;
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = size;
    tempCanvas.height = size;
    const tempCtx = tempCanvas.getContext('2d');

    spriteFunc(tempCtx, size, size, animationFrame,
        options.active, options.overheated, options.charge,
        options.rotation, options.frozen, options.moving, options.state);

    const scale = game.camera.zoom;
    ctx.drawImage(tempCanvas,
        x - (size * scale) / 2,
        y - (size * scale) * 0.75,
        size * scale,
        size * scale);
}

// ==================== THEME SELECTION ====================
function selectTheme(theme) {
    game.theme = theme;
    applyTheme(theme);
    document.getElementById('themeModal').style.display = 'none';
    document.getElementById('ui').style.display = 'block';
    startGame();
}

function applyTheme(theme) {
    const themeVars = THEMES[theme];
    for (const [key, value] of Object.entries(themeVars)) {
        document.documentElement.style.setProperty(key, value);
    }
}

// ==================== ISOMETRIC HELPERS ====================
function worldToScreen(x, y) {
    const isoX = (x - y) * (CONFIG.TILE_WIDTH / 2);
    const isoY = (x + y) * (CONFIG.TILE_HEIGHT / 2);

    const screenX = (isoX - game.camera.x) * game.camera.zoom + canvas.width / 2;
    const screenY = (isoY - game.camera.y) * game.camera.zoom + canvas.height / 2;

    return { x: screenX, y: screenY };
}

function screenToWorld(screenX, screenY) {
    const isoX = (screenX - canvas.width / 2) / game.camera.zoom + game.camera.x;
    const isoY = (screenY - canvas.height / 2) / game.camera.zoom + game.camera.y;

    const x = (isoX / (CONFIG.TILE_WIDTH / 2) + isoY / (CONFIG.TILE_HEIGHT / 2)) / 2;
    const y = (isoY / (CONFIG.TILE_HEIGHT / 2) - isoX / (CONFIG.TILE_WIDTH / 2)) / 2;

    return { x: Math.floor(x), y: Math.floor(y) };
}

function wrapCoord(val) {
    return ((val % CONFIG.MAP_SIZE) + CONFIG.MAP_SIZE) % CONFIG.MAP_SIZE;
}

// ==================== WORLD GENERATION ====================
function generateWorld() {
    // Initialize tiles
    game.tiles = [];
    game.explored = [];
    game.cables = [];
    game.cableStart = null;

    for (let y = 0; y < CONFIG.MAP_SIZE; y++) {
        game.tiles[y] = [];
        game.explored[y] = [];
        for (let x = 0; x < CONFIG.MAP_SIZE; x++) {
            // Basic terrain generation using simple noise
            const noise = Math.sin(x * 0.1) * Math.cos(y * 0.1) +
                         Math.sin(x * 0.05 + y * 0.05) * 0.5;

            let type = 'snow';
            if (noise > 0.3) type = 'ice';
            if (noise < -0.5) type = 'rock';

            game.tiles[y][x] = {
                type: type,
                temperature: CONFIG.PLANETS[game.planet].baseTemp
            };
            game.explored[y][x] = false;
        }
    }

    // Generate resource nodes - more near spawn, fewer far away
    game.resources = [];
    const spawnX = 256, spawnY = 256;
    const baseNodeCount = Math.floor(CONFIG.MAP_SIZE * CONFIG.MAP_SIZE * 0.004);

    for (let i = 0; i < baseNodeCount; i++) {
        const x = Math.floor(Math.random() * CONFIG.MAP_SIZE);
        const y = Math.floor(Math.random() * CONFIG.MAP_SIZE);

        // Calculate distance from spawn (with wrap-around)
        let dx = Math.abs(x - spawnX);
        let dy = Math.abs(y - spawnY);
        if (dx > CONFIG.MAP_SIZE / 2) dx = CONFIG.MAP_SIZE - dx;
        if (dy > CONFIG.MAP_SIZE / 2) dy = CONFIG.MAP_SIZE - dy;
        const distFromSpawn = Math.sqrt(dx * dx + dy * dy);

        // Higher chance to skip nodes that are far from spawn
        // Close nodes (< 50 tiles): 100% spawn
        // Medium nodes (50-150): 70% spawn
        // Far nodes (> 150): 40% spawn
        const spawnChance = distFromSpawn < 50 ? 1.0 :
                           distFromSpawn < 150 ? 0.7 : 0.4;
        if (Math.random() > spawnChance) continue;

        // Determine resource type based on planet
        let resourceType = 'iron_ore';
        const roll = Math.random();

        if (roll < 0.4) resourceType = 'iron_ore';
        else if (roll < 0.7) resourceType = 'copper_ore';
        else if (roll < 0.9) resourceType = 'coal';
        else if (game.planet !== 'terra_prime' && roll < 0.95) resourceType = 'crystal';

        game.resources.push({
            x: x,
            y: y,
            type: resourceType,
            amount: 50 + Math.floor(Math.random() * 100)
        });
    }

    // Add guaranteed resource cluster near spawn
    for (let i = 0; i < 15; i++) {
        const angle = (i / 15) * Math.PI * 2;
        const dist = 8 + Math.random() * 25;
        const x = Math.floor(spawnX + Math.cos(angle) * dist);
        const y = Math.floor(spawnY + Math.sin(angle) * dist);

        const types = ['iron_ore', 'copper_ore', 'coal'];
        game.resources.push({
            x: wrapCoord(x),
            y: wrapCoord(y),
            type: types[i % 3],
            amount: 80 + Math.floor(Math.random() * 70)
        });
    }

    // Generate NPCs - spawn away from player start (256,256)
    game.npcs = [
        {
            type: 'scrap_dealer',
            name: 'Scrap Dealer',
            x: 280,
            y: 280,
            icon: 'üßî',
            buys: ['iron_ore', 'copper_ore', 'coal'],
            sells: ['miner', 'furnace', 'heater', 'solar_panel']
        },
        {
            type: 'parts_merchant',
            name: 'Parts Merchant',
            x: 295,
            y: 270,
            icon: 'üë®‚Äçüîß',
            buys: ['iron_ingot', 'copper_ingot', 'steel', 'circuit'],
            sells: ['assembler', 'battery', 'conveyor', 'storage']
        },
        {
            type: 'collector',
            name: 'Collector',
            x: 310,
            y: 290,
            icon: 'üé©',
            buys: ['crystal', 'dark_matter', 'quantum_ore'],
            sells: ['landing_pad', 'repair_robot', 'extinguisher']
        }
    ];

    // Place tutorial loadout near spawn
    setupTutorialLoadout();
}

function setupTutorialLoadout() {
    const spawnX = 256;
    const spawnY = 256;

    // Find nearest iron node or create one
    let ironNode = game.resources.find(r =>
        r.type === 'iron_ore' &&
        Math.abs(r.x - spawnX) < 10 &&
        Math.abs(r.y - spawnY) < 10
    );

    if (!ironNode) {
        ironNode = { x: spawnX + 2, y: spawnY + 2, type: 'iron_ore', amount: 100 };
        game.resources.push(ironNode);
    }

    // Place miner on node
    game.machines.push(createMachine('miner', ironNode.x, ironNode.y));

    // Place solar panel nearby
    game.machines.push(createMachine('solar_panel', spawnX + 3, spawnY + 1));

    // Place heater
    game.machines.push(createMachine('heater', spawnX + 2, spawnY + 1));

    // Place storage
    const storage = createMachine('storage', spawnX + 1, spawnY + 3);
    storage.inventory = [
        { type: 'iron_ore', count: 5 },
        { type: 'coal', count: 3 }
    ];
    game.machines.push(storage);

    // Place battery
    const batt = createMachine('battery', spawnX + 4, spawnY + 1);
    batt.stored = 50;
    game.machines.push(batt);

    // Explore area around spawn (circular)
    const exploreRadius = 10;
    for (let dy = -exploreRadius; dy <= exploreRadius; dy++) {
        for (let dx = -exploreRadius; dx <= exploreRadius; dx++) {
            if (dx * dx + dy * dy <= exploreRadius * exploreRadius) {
                const ex = wrapCoord(spawnX + dx);
                const ey = wrapCoord(spawnY + dy);
                game.explored[ey][ex] = true;
            }
        }
    }

    // Give robot starting items for basic machines
    game.robot.inventory = [
        { type: 'iron_ore', count: 10 },
        { type: 'copper_ore', count: 8 },
        { type: 'coal', count: 5 },
        { type: 'iron_ingot', count: 5 },
        { type: 'copper_ingot', count: 4 },
        { type: 'cable', count: 10 }
    ];
}

function createMachine(type, x, y) {
    const def = MACHINES[type];
    return {
        type: type,
        x: x,
        y: y,
        hp: 100,
        maxHp: 100,
        temperature: 20,
        powered: false,
        active: false,
        inventory: [],
        stored: 0,
        rotation: 0,
        onTime: 0,
        onFire: false,
        fireTimer: 0
    };
}

// ==================== INPUT HANDLING ====================
const keys = {};
let mouseX = 0, mouseY = 0;
let mouseDown = false;
let middleMouseDown = false;
let lastMouseX = 0, lastMouseY = 0;
let selectedBuild = null;
let buildRotation = 0;

document.addEventListener('keydown', (e) => {
    keys[e.key.toLowerCase()] = true;

    // Cheat code detection
    game.cheatBuffer += e.key.toLowerCase();
    if (game.cheatBuffer.length > 10) {
        game.cheatBuffer = game.cheatBuffer.slice(-10);
    }
    if (game.cheatBuffer.includes('levitysm')) {
        game.cheatsEnabled = true;
        game.cheatBuffer = '';
        document.getElementById('cheatMenu').style.display = 'block';
        notify('Cheat menu activated!', 'warning');
    }

    // Key bindings
    if (e.key === ' ') {
        e.preventDefault();
        togglePause();
    }
    if (e.key.toLowerCase() === 'i') {
        toggleInventory();
    }
    if (e.key.toLowerCase() === 'f') {
        game.camera.following = !game.camera.following;
        notify(game.camera.following ? 'Camera following robot' : 'Camera free');
    }
    if (e.key.toLowerCase() === 'r' && selectedBuild) {
        buildRotation = (buildRotation + 1) % 4;
    }
    if (e.key === 'Tab') {
        e.preventDefault();
    }
    if (e.key === 'Escape') {
        selectedBuild = null;
        document.getElementById('machineMenu').style.display = 'none';
        closeTradeModal();
        closeTravelModal();
    }

    // Rocket launcher mode switching
    if (game.cheatsActive.rocketLauncher) {
        if (e.key === '1') {
            game.rocketMode = 'destroy';
            notify('Rocket mode: DESTROY');
        } else if (e.key === '2') {
            game.rocketMode = 'clear';
            notify('Rocket mode: CLEAR TERRAIN');
        } else if (e.key === '3') {
            game.rocketMode = 'launch';
            notify('Rocket mode: LAUNCH ROBOT');
        }
    }
});

document.addEventListener('keyup', (e) => {
    keys[e.key.toLowerCase()] = false;
});

canvas.addEventListener('mousemove', (e) => {
    mouseX = e.clientX;
    mouseY = e.clientY;

    if (middleMouseDown) {
        const dx = e.clientX - lastMouseX;
        const dy = e.clientY - lastMouseY;
        game.camera.x -= dx / game.camera.zoom;
        game.camera.y -= dy / game.camera.zoom;
        game.camera.following = false;
    }

    lastMouseX = e.clientX;
    lastMouseY = e.clientY;
});

canvas.addEventListener('mousedown', (e) => {
    if (e.button === 0) {
        mouseDown = true;
        handleLeftClick(e);
    } else if (e.button === 1) {
        middleMouseDown = true;
        e.preventDefault();
    } else if (e.button === 2) {
        handleRightClick(e);
    }
});

canvas.addEventListener('mouseup', (e) => {
    if (e.button === 0) mouseDown = false;
    if (e.button === 1) middleMouseDown = false;
});

canvas.addEventListener('wheel', (e) => {
    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
    game.camera.zoom = Math.max(0.25, Math.min(3, game.camera.zoom * zoomFactor));
    e.preventDefault();
});

canvas.addEventListener('contextmenu', (e) => e.preventDefault());

function handleLeftClick(e) {
    const worldPos = screenToWorld(e.clientX, e.clientY);
    const wx = wrapCoord(Math.floor(worldPos.x));
    const wy = wrapCoord(Math.floor(worldPos.y));

    // Rocket launcher takes priority
    if (game.cheatsActive.rocketLauncher) {
        fireRocket(worldPos.x, worldPos.y);
        return;
    }

    if (selectedBuild) {
        // Handle cable tool specially
        if (selectedBuild === 'cable_tool') {
            const machine = getMachineAt(wx, wy);
            if (machine) {
                handleCableConnection(machine);
            } else {
                notify('Click on a machine to connect', 'warning');
            }
            return;
        }

        // Place building
        placeMachine(selectedBuild, wx, wy);
    } else {
        // Check for machine interaction
        const machine = getMachineAt(wx, wy);
        if (machine) {
            showMachineInfo(machine);
        } else {
            // Check for NPC
            const npc = game.npcs.find(n => n.x === wx && n.y === wy);
            if (npc) {
                interactWithNPC(npc);
            } else {
                // Check for resource pickup
                const resource = game.resources.find(r => r.x === wx && r.y === wy);
                if (resource && isAdjacent(game.robot.x, game.robot.y, wx, wy)) {
                    mineResource(resource);
                }
            }
        }
    }
}

function handleCableConnection(machine) {
    if (!game.cableStart) {
        // First machine selected
        game.cableStart = machine;
        notify(`Cable start: ${MACHINES[machine.type].name} - Click another machine to connect`);
    } else if (game.cableStart === machine) {
        // Clicked same machine, cancel
        game.cableStart = null;
        notify('Cable connection cancelled');
    } else {
        // Second machine - create connection
        const start = game.cableStart;
        const end = machine;

        // Check if connection already exists
        const existingCable = game.cables.find(c =>
            (c.from.x === start.x && c.from.y === start.y && c.to.x === end.x && c.to.y === end.y) ||
            (c.from.x === end.x && c.from.y === end.y && c.to.x === start.x && c.to.y === start.y)
        );

        if (existingCable) {
            notify('Machines already connected!', 'warning');
        } else {
            // Check for cable resource
            const cableItem = game.robot.inventory.find(i => i.type === 'cable');
            if (!cableItem || cableItem.count < 1) {
                if (!game.cheatsActive.freeCrafting) {
                    notify('Need 1 Cable to connect machines', 'warning');
                    game.cableStart = null;
                    return;
                }
            } else if (!game.cheatsActive.freeCrafting) {
                cableItem.count--;
                if (cableItem.count <= 0) {
                    game.robot.inventory = game.robot.inventory.filter(i => i.count > 0);
                }
            }

            // Create cable connection
            game.cables.push({
                from: { x: start.x, y: start.y },
                to: { x: end.x, y: end.y }
            });
            notify(`Connected ${MACHINES[start.type].name} to ${MACHINES[end.type].name}`);
        }

        game.cableStart = null;
    }
}

function handleRightClick(e) {
    if (selectedBuild) {
        selectedBuild = null;
    } else {
        const worldPos = screenToWorld(e.clientX, e.clientY);
        const wx = wrapCoord(Math.floor(worldPos.x));
        const wy = wrapCoord(Math.floor(worldPos.y));

        const machine = getMachineAt(wx, wy);
        if (machine) {
            showMachineMenu(machine, e.clientX, e.clientY);
        }
    }
}

function getMachineAt(x, y) {
    return game.machines.find(m => m.x === x && m.y === y);
}

function isAdjacent(x1, y1, x2, y2) {
    const dx = Math.abs(x1 - x2);
    const dy = Math.abs(y1 - y2);
    return dx <= 2 && dy <= 2;
}

// ==================== BUILD MENU ====================
function renderBuildMenuSprite(type) {
    const spriteFunc = SPRITES[type];
    const size = 64;
    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');

    if (spriteFunc) {
        // Create a temporary larger canvas for the sprite
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = 128;
        tempCanvas.height = 128;
        const tempCtx = tempCanvas.getContext('2d');

        // Render sprite at full size
        spriteFunc(tempCtx, 128, 128, 0, true, false, 50, 0, false, false, 'idle');

        // Scale down to fit build menu
        ctx.drawImage(tempCanvas, 16, 32, 96, 96, 0, 0, size, size);
    } else {
        // Fallback to emoji if no sprite
        const machine = MACHINES[type];
        ctx.fillStyle = machine.color || '#666';
        ctx.fillRect(8, 8, size - 16, size - 16);
        ctx.font = '24px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(machine.icon, size / 2, size / 2);
    }

    return canvas.toDataURL();
}

function initBuildMenu() {
    const menu = document.getElementById('buildMenu');
    menu.innerHTML = '';

    for (const [key, machine] of Object.entries(MACHINES)) {
        const item = document.createElement('div');
        item.className = 'build-item';

        // Render sprite as image
        const img = document.createElement('img');
        img.src = renderBuildMenuSprite(key);
        img.style.width = '100%';
        img.style.height = '100%';
        img.style.objectFit = 'contain';
        img.draggable = false;
        item.appendChild(img);

        // Build tooltip with cost
        let tooltip = machine.name + '\n';
        for (const [res, count] of Object.entries(machine.cost)) {
            const resName = RESOURCES[res]?.name || res;
            tooltip += `${count}x ${resName}\n`;
        }
        item.title = tooltip.trim();

        item.onclick = function() { selectBuild(key, this); };
        menu.appendChild(item);
    }
}

function selectBuild(type, element) {
    selectedBuild = type;
    document.querySelectorAll('.build-item').forEach(el => el.classList.remove('selected'));
    if (element) element.classList.add('selected');

    // Update selectedInfo panel with building info
    const machine = MACHINES[type];
    const info = document.getElementById('selectedInfo');

    let costHtml = '';
    for (const [res, count] of Object.entries(machine.cost)) {
        const resName = RESOURCES[res]?.name || res;
        const resColor = RESOURCES[res]?.color || '#fff';
        const hasEnough = game.robot.inventory.find(i => i.type === res && i.count >= count);
        const color = hasEnough ? '#8f8' : '#f88';
        costHtml += `<div style="color: ${color}; font-size: 11px;">‚Ä¢ ${count}x ${resName}</div>`;
    }

    info.innerHTML = `
        <h4 style="color: var(--ui-accent);">${machine.icon} ${machine.name}</h4>
        <p style="font-size: 11px; margin: 5px 0; opacity: 0.8;">${machine.desc || 'Click on map to place'}</p>
        <div style="margin-top: 8px;">
            <div style="font-size: 10px; color: #aaa; margin-bottom: 3px;">COST:</div>
            ${costHtml}
        </div>
        <div style="font-size: 10px; color: #888; margin-top: 8px;">Power: ${machine.power > 0 ? '+' + machine.power : machine.power}/s</div>
    `;

    notify(`Selected: ${machine.name}`);
}

function placeMachine(type, x, y) {
    // Check if we can afford it
    const def = MACHINES[type];

    if (!game.cheatsActive.freeCrafting) {
        // Check inventory for materials
        for (const [resource, count] of Object.entries(def.cost)) {
            const item = game.robot.inventory.find(i => i.type === resource);
            if (!item || item.count < count) {
                notify(`Need ${count} ${RESOURCES[resource]?.name || resource}`, 'warning');
                return;
            }
        }

        // Deduct materials
        for (const [resource, count] of Object.entries(def.cost)) {
            const item = game.robot.inventory.find(i => i.type === resource);
            item.count -= count;
            if (item.count <= 0) {
                game.robot.inventory = game.robot.inventory.filter(i => i.count > 0);
            }
        }
    }

    // Check if tile is free
    if (getMachineAt(x, y)) {
        notify('Tile occupied!', 'warning');
        return;
    }

    // Place machine
    const machine = createMachine(type, x, y);
    machine.rotation = buildRotation;
    game.machines.push(machine);
    game.stats.machinesBuilt++;

    // Special handling for sun_tracker - spawn a tracker robot
    if (type === 'sun_tracker') {
        // Find nearby battery bank
        const nearbyBank = game.machines.find(m =>
            m.type === 'battery_bank' &&
            Math.abs(m.x - x) < 5 &&
            Math.abs(m.y - y) < 5
        );

        if (nearbyBank) {
            spawnSunTracker(nearbyBank);
        } else {
            notify('Place near a Battery Bank for best results!', 'warning');
            // Still spawn but use this machine's location
            spawnSunTracker(machine);
        }
    }

    notify(`Placed ${def.name}`);
}

// ==================== ROBOT MOVEMENT ====================
function updateRobot(dt) {
    if (game.robot.frozen) {
        // Check for rescue (sun thawing)
        if (game.isDay) {
            game.robot.temperature += 5 * dt;
            if (game.robot.temperature > 0) {
                game.robot.frozen = false;
                game.robot.battery = 10;
                notify('Robot thawed by sunlight!');
            }
        }
        return;
    }

    // Movement
    let dx = 0, dy = 0;
    const speed = 3;

    if (keys['w']) { dx -= 1; dy -= 1; }
    if (keys['s']) { dx += 1; dy += 1; }
    if (keys['a']) { dx -= 1; dy += 1; }
    if (keys['d']) { dx += 1; dy -= 1; }

    if (dx !== 0 || dy !== 0) {
        const len = Math.sqrt(dx * dx + dy * dy);
        dx /= len;
        dy /= len;

        game.robot.x += dx * speed * dt;
        game.robot.y += dy * speed * dt;

        // Wrap around
        game.robot.x = wrapCoord(game.robot.x);
        game.robot.y = wrapCoord(game.robot.y);

        // Battery drain while moving
        game.robot.battery -= 0.1 * dt;
    }

    // Explore tiles around robot (circular radius)
    const rx = Math.floor(game.robot.x);
    const ry = Math.floor(game.robot.y);
    const visionRadius = 6;
    for (let dy = -visionRadius; dy <= visionRadius; dy++) {
        for (let dx = -visionRadius; dx <= visionRadius; dx++) {
            // Check if within circular radius
            if (dx * dx + dy * dy <= visionRadius * visionRadius) {
                const ex = wrapCoord(rx + dx);
                const ey = wrapCoord(ry + dy);
                game.explored[ey][ex] = true;
            }
        }
    }

    // Temperature management
    let heatGain = 0;

    // Sun heat
    if (game.isDay) heatGain += 30;

    // Nearby heaters
    game.machines.forEach(m => {
        if (m.type === 'heater' && m.powered && !m.onFire) {
            const dist = Math.sqrt(Math.pow(m.x - game.robot.x, 2) + Math.pow(m.y - game.robot.y, 2));
            if (dist < 5) {
                heatGain += 20 / (dist + 1);
            }
        }
    });

    // Planet base temp
    const planetBase = CONFIG.PLANETS[game.planet].baseTemp;
    const targetTemp = planetBase + heatGain;

    game.robot.temperature += (targetTemp - game.robot.temperature) * 0.1 * dt;

    // Battery drain from internal heater
    if (game.robot.temperature < 10) {
        game.robot.battery -= 0.5 * dt;
    }

    // Freeze check
    if (game.robot.battery <= 0 && !game.cheatsActive.noDeath) {
        game.robot.battery = 0;
        game.robot.frozen = true;
        notify('Robot frozen! Waiting for rescue...', 'danger');
    }

    // Camera follow
    if (game.camera.following) {
        const targetCamX = (game.robot.x - game.robot.y) * (CONFIG.TILE_WIDTH / 2);
        const targetCamY = (game.robot.x + game.robot.y) * (CONFIG.TILE_HEIGHT / 2);
        game.camera.x += (targetCamX - game.camera.x) * 0.1;
        game.camera.y += (targetCamY - game.camera.y) * 0.1;
    }
}

// ==================== MACHINE UPDATES ====================
function updateMachines(dt) {
    // Calculate total power
    let powerGen = 0;
    let powerUse = 0;
    let batteryStored = 0;

    game.machines.forEach(m => {
        const def = MACHINES[m.type];
        if (!def) return;

        if (def.power > 0) {
            // Generator
            if (m.type === 'solar_panel' && game.isDay) {
                powerGen += def.power;
            } else if (m.type === 'generator') {
                // Check for fuel in inventory
                const fuel = m.inventory.find(i => i.type === 'coal');
                if (fuel && fuel.count > 0) {
                    powerGen += def.power;
                    // Consume fuel slowly
                    if (Math.random() < dt * 0.033) { // ~1 coal per 30 sec
                        fuel.count--;
                        if (fuel.count <= 0) {
                            m.inventory = m.inventory.filter(i => i.count > 0);
                        }
                    }
                }
            }
        } else if (def.power < 0) {
            powerUse += Math.abs(def.power);
        }

        // Battery and battery bank contribute stored power
        if ((m.type === 'battery' || m.type === 'battery_bank') && m.stored > 0) {
            batteryStored += m.stored;
        }
    });

    // Determine if we have enough power
    let powerDeficit = powerUse - powerGen;
    let hasPower = true;

    if (powerDeficit > 0) {
        // Draw from batteries
        const drainRate = powerDeficit * dt;
        game.machines.forEach(m => {
            if ((m.type === 'battery' || m.type === 'battery_bank') && m.stored > 0 && powerDeficit > 0) {
                const drain = Math.min(m.stored, drainRate);
                m.stored -= drain;
                powerDeficit -= drain / dt;
            }
        });

        hasPower = powerDeficit <= 0;
    } else if (powerGen > powerUse) {
        // Charge batteries
        const chargeRate = (powerGen - powerUse) * dt;
        game.machines.forEach(m => {
            if (m.type === 'battery' || m.type === 'battery_bank') {
                const def = MACHINES[m.type];
                const capacity = def.capacity || 100;
                if (m.stored < capacity) {
                    m.stored = Math.min(capacity, (m.stored || 0) + chargeRate * 0.5);
                }
            }
        });
    }

    // Update each machine
    game.machines.forEach(m => {
        const def = MACHINES[m.type];
        if (!def) return;

        m.powered = hasPower;

        // Temperature
        let heatGain = def.heat;
        if (game.isDay) heatGain += 15;

        // Nearby heaters/coolers
        game.machines.forEach(other => {
            if (other === m) return;
            const dist = Math.sqrt(Math.pow(other.x - m.x, 2) + Math.pow(other.y - m.y, 2));
            if (dist < 4) {
                const otherDef = MACHINES[other.type];
                if (otherDef && other.powered) {
                    heatGain += otherDef.heat / (dist + 1);
                }
            }
        });

        const planetBase = CONFIG.PLANETS[game.planet].baseTemp;
        const targetTemp = planetBase + heatGain;
        m.temperature += (targetTemp - m.temperature) * 0.05 * dt;

        // Temperature states
        if (m.temperature < -20) {
            // Frozen
            m.active = false;
            if (m.temperature < -30) {
                m.hp -= 0.1 * dt; // Freeze damage
            }
        } else if (m.temperature < 0) {
            // Cold - 50% efficiency
            m.active = m.powered;
        } else if (m.temperature > 80) {
            // Overheating
            if (def.fireRisk) {
                m.onTime += dt;
                if (m.onTime > 60 && Math.random() < 0.01 * dt) {
                    m.onFire = true;
                    notify(`${def.name} caught fire!`, 'danger');
                }
            }
        } else {
            m.active = m.powered;
            m.onTime = 0;
        }

        // Fire spreading
        if (m.onFire) {
            m.hp -= 10 * dt;
            m.fireTimer += dt;

            if (m.fireTimer >= 5) {
                m.fireTimer = 0;
                // Spread to adjacent
                game.machines.forEach(other => {
                    if (other.onFire) return;
                    const dist = Math.sqrt(Math.pow(other.x - m.x, 2) + Math.pow(other.y - m.y, 2));
                    if (dist <= 1.5 && Math.random() < 0.5) {
                        other.onFire = true;
                        notify('Fire spreading!', 'danger');
                    }
                });
            }

            // Check for extinguisher
            game.machines.forEach(ext => {
                if (ext.type === 'extinguisher' && ext.powered) {
                    const dist = Math.sqrt(Math.pow(ext.x - m.x, 2) + Math.pow(ext.y - m.y, 2));
                    if (dist <= 5) {
                        m.onFire = false;
                        m.fireTimer = 0;
                    }
                }
            });
        }

        // Destruction
        if (m.hp <= 0) {
            notify(`${def.name} destroyed!`, 'danger');
            game.machines = game.machines.filter(mm => mm !== m);
            // Create explosion particles
            for (let i = 0; i < 10; i++) {
                game.particles.push({
                    x: m.x,
                    y: m.y,
                    vx: (Math.random() - 0.5) * 5,
                    vy: (Math.random() - 0.5) * 5,
                    life: 1,
                    color: '#ff4400'
                });
            }
        }

        // Mining
        if (m.type === 'miner' && m.active) {
            const node = game.resources.find(r => r.x === m.x && r.y === m.y);
            if (node && node.amount > 0) {
                node.amount -= dt * 0.5;
                // Output to storage or conveyor
                if (Math.random() < dt * 0.2) {
                    addToMachineInventory(m, node.type, 1);
                }
            }
        }

        // Water mining
        if (m.type === 'water_miner' && m.active) {
            if (game.tiles[wrapCoord(m.y)][wrapCoord(m.x)].type === 'ice') {
                if (Math.random() < dt * 0.15) {
                    addToMachineInventory(m, 'water', 1);
                }
            }
        }

        // Processing machines (furnace, assembler, fuel_refinery)
        if (['furnace', 'assembler', 'fuel_refinery'].includes(m.type) && m.active) {
            const recipes = RECIPES[m.type] || [];

            // Initialize processing state if needed
            if (!m.processing) m.processing = null;
            if (!m.processTime) m.processTime = 0;

            if (m.processing) {
                // Continue processing current recipe
                m.processTime += dt;
                if (m.processTime >= m.processing.time) {
                    // Output finished product
                    for (const [item, count] of Object.entries(m.processing.output)) {
                        addToMachineInventory(m, item, count);
                    }
                    m.processing = null;
                    m.processTime = 0;
                }
            } else {
                // Try to start a new recipe
                for (const recipe of recipes) {
                    let canCraft = true;
                    for (const [item, count] of Object.entries(recipe.inputs)) {
                        const inv = m.inventory.find(i => i.type === item);
                        if (!inv || inv.count < count) {
                            canCraft = false;
                            break;
                        }
                    }

                    if (canCraft) {
                        // Consume inputs
                        for (const [item, count] of Object.entries(recipe.inputs)) {
                            const inv = m.inventory.find(i => i.type === item);
                            inv.count -= count;
                            if (inv.count <= 0) {
                                m.inventory = m.inventory.filter(i => i.count > 0);
                            }
                        }
                        m.processing = recipe;
                        m.processTime = 0;
                        break;
                    }
                }
            }
        }

        // Conveyor belt logic
        if (m.type === 'conveyor' && m.active && m.inventory.length > 0) {
            // Find adjacent machine in direction
            const directions = [
                { dx: 1, dy: 0 },
                { dx: 0, dy: 1 },
                { dx: -1, dy: 0 },
                { dx: 0, dy: -1 }
            ];
            const dir = directions[m.rotation % 4];
            const targetX = wrapCoord(m.x + dir.dx);
            const targetY = wrapCoord(m.y + dir.dy);
            const target = getMachineAt(targetX, targetY);

            if (target && m.inventory.length > 0) {
                const item = m.inventory[0];
                addToMachineInventory(target, item.type, 1);
                item.count--;
                if (item.count <= 0) {
                    m.inventory.shift();
                }
            }
        }

        // Repair robot logic
        if (m.type === 'repair_robot' && m.active) {
            // Find damaged machine nearby
            const damaged = game.machines.find(other =>
                other !== m &&
                other.hp < other.maxHp &&
                Math.abs(other.x - m.x) <= 5 &&
                Math.abs(other.y - m.y) <= 5
            );

            if (damaged) {
                damaged.hp = Math.min(damaged.maxHp, damaged.hp + 10 * dt);
            }
        }

        // Landing pad - check for interaction
        if (m.type === 'landing_pad' && m.active) {
            // Check if player is on pad
            if (Math.abs(game.robot.x - m.x) < 1.5 && Math.abs(game.robot.y - m.y) < 1.5) {
                m.playerOnPad = true;
            } else {
                m.playerOnPad = false;
            }
        }
    });
}

function addToMachineInventory(machine, type, count) {
    const existing = machine.inventory.find(i => i.type === type);
    if (existing) {
        existing.count += count;
    } else {
        machine.inventory.push({ type, count });
    }
}

// ==================== DAY/NIGHT CYCLE ====================

// Get the sun's X position on the map (0 to MAP_SIZE), representing the terminator line
function getSunPosition() {
    const planet = CONFIG.PLANETS[game.planet];
    const cycleLength = planet.dayLength + planet.nightLength;

    if (cycleLength === Infinity) {
        return -1; // No sun on Space Rock-024
    }

    // Sun moves across the map during the cycle
    // At dawn (dayTime = 0): sun at left edge (x = 0)
    // At noon (dayTime = dayLength/2): sun at center (x = MAP_SIZE/2)
    // At dusk (dayTime = dayLength): sun at right edge (x = MAP_SIZE)
    // During night: sun continues past right edge (off map)

    const fullCycleProgress = game.dayTime / cycleLength;
    // Sun completes a full sweep during the cycle
    const sunX = fullCycleProgress * CONFIG.MAP_SIZE;

    return sunX;
}

// Get light level for a tile based on distance from sun/terminator
// Returns 0.0 (full dark) to 1.0 (full light)
function getTileLightLevel(tileX) {
    const planet = CONFIG.PLANETS[game.planet];
    const cycleLength = planet.dayLength + planet.nightLength;

    if (cycleLength === Infinity) {
        return 0.0; // Always dark on Space Rock-024
    }

    const sunX = getSunPosition();
    const waveWidth = 8; // Width of the transition zone in tiles

    // Calculate distance from tile to sun position (accounting for wrap-around)
    let dx = tileX - sunX;

    // Normalize dx to account for map wrap-around
    if (dx > CONFIG.MAP_SIZE / 2) dx -= CONFIG.MAP_SIZE;
    if (dx < -CONFIG.MAP_SIZE / 2) dx += CONFIG.MAP_SIZE;

    // Daylight covers about half the map, centered on the sun
    const daylightRadius = CONFIG.MAP_SIZE / 4;
    const absDist = Math.abs(dx);

    if (absDist < daylightRadius - waveWidth) {
        // Fully in daylight
        return 1.0;
    } else if (absDist > daylightRadius + waveWidth) {
        // Fully in darkness
        return 0.15; // Not completely black, some ambient light
    } else {
        // In the transition zone (the wave)
        const transitionPos = (absDist - (daylightRadius - waveWidth)) / (waveWidth * 2);
        return 1.0 - (transitionPos * 0.85); // Smooth gradient from 1.0 to 0.15
    }
}

function updateDayNight(dt) {
    const planet = CONFIG.PLANETS[game.planet];
    const cycleLength = planet.dayLength + planet.nightLength;

    if (cycleLength === Infinity) {
        // Space Rock-024: always night
        game.isDay = false;
        game.dayTime = 0;
        return;
    }

    game.dayTime += dt * 1000;

    if (game.dayTime >= cycleLength) {
        game.dayTime = 0;
    }

    game.isDay = game.dayTime < planet.dayLength;

    // Update UI
    const progress = game.dayTime / cycleLength;
    document.getElementById('dayNightFill').style.width = `${progress * 100}%`;

    const timeInPhase = game.isDay ? game.dayTime : game.dayTime - planet.dayLength;
    const phaseLength = game.isDay ? planet.dayLength : planet.nightLength;
    const minutes = Math.floor((timeInPhase / phaseLength) * (game.isDay ? 10 : 15));
    const seconds = Math.floor(((timeInPhase / phaseLength) * (game.isDay ? 10 : 15) % 1) * 60);

    document.getElementById('dayNightText').textContent =
        `${game.isDay ? 'DAY' : 'NIGHT'} ${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
}

// ==================== RENDERING ====================
const CHUNK_SIZE = 16;

function renderChunk(chunkX, chunkY) {
    const baseX = chunkX * CHUNK_SIZE;
    const baseY = chunkY * CHUNK_SIZE;

    for (let dy = 0; dy < CHUNK_SIZE; dy++) {
        for (let dx = 0; dx < CHUNK_SIZE; dx++) {
            const x = baseX + dx;
            const y = baseY + dy;
            const wx = wrapCoord(x);
            const wy = wrapCoord(y);

            // Skip unexplored tiles
            if (!game.explored[wy] || !game.explored[wy][wx]) continue;

            const screen = worldToScreen(x, y);

            // Skip if off-screen
            if (screen.x < -CONFIG.TILE_WIDTH || screen.x > canvas.width + CONFIG.TILE_WIDTH) continue;
            if (screen.y < -CONFIG.TILE_HEIGHT * 2 || screen.y > canvas.height + CONFIG.TILE_HEIGHT * 2) continue;

            const tile = game.tiles[wy][wx];
            // Get light level based on tile's visual X position (unwrapped) for smooth transitions
            const lightLevel = getTileLightLevel(x);
            drawIsometricTile(screen.x, screen.y, getTileColor(tile.type), lightLevel);
        }
    }
}

// ==================== CABLE RENDERING HELPERS (Factorio-style) ====================

// Draw a catenary curve (realistic wire sag)
function drawCatenaryWire(ctx, x1, y1, x2, y2, sag) {
    ctx.beginPath();
    ctx.moveTo(x1, y1);

    // Use quadratic bezier for catenary approximation
    // Control point at midpoint, offset down by sag amount
    const midX = (x1 + x2) / 2;
    const midY = (y1 + y2) / 2 + sag;

    ctx.quadraticCurveTo(midX, midY, x2, y2);
    ctx.stroke();
}

// Draw connector/insulator at cable endpoint
function drawCableConnector(ctx, x, y, zoom) {
    // Ceramic insulator base (darker)
    ctx.fillStyle = '#4a4a4a';
    ctx.beginPath();
    ctx.ellipse(x, y + 2 * zoom, 4 * zoom, 2 * zoom, 0, 0, Math.PI * 2);
    ctx.fill();

    // Metal connector (copper colored)
    ctx.fillStyle = '#b87333';
    ctx.beginPath();
    ctx.arc(x, y, 3 * zoom, 0, Math.PI * 2);
    ctx.fill();

    // Highlight on metal
    ctx.fillStyle = '#dda066';
    ctx.beginPath();
    ctx.arc(x - 1 * zoom, y - 1 * zoom, 1.5 * zoom, 0, Math.PI * 2);
    ctx.fill();

    // Small bolt detail
    ctx.fillStyle = '#666666';
    ctx.beginPath();
    ctx.arc(x, y, 1 * zoom, 0, Math.PI * 2);
    ctx.fill();
}

function render() {
    // Clear
    ctx.fillStyle = game.isDay ? '#1a2a3a' : '#0a0a12';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Calculate visible range
    const topLeft = screenToWorld(0, 0);
    const bottomRight = screenToWorld(canvas.width, canvas.height);

    // Chunk-based rendering for better performance
    const startChunkX = Math.floor((topLeft.x - 10) / CHUNK_SIZE);
    const endChunkX = Math.ceil((bottomRight.x + 10) / CHUNK_SIZE);
    const startChunkY = Math.floor((topLeft.y - 10) / CHUNK_SIZE);
    const endChunkY = Math.ceil((bottomRight.y + 10) / CHUNK_SIZE);

    // Draw tiles by chunk
    for (let chunkY = startChunkY; chunkY <= endChunkY; chunkY++) {
        for (let chunkX = startChunkX; chunkX <= endChunkX; chunkX++) {
            renderChunk(chunkX, chunkY);
        }
    }

    // Draw resources
    game.resources.forEach(r => {
        if (!game.explored[wrapCoord(r.y)][wrapCoord(r.x)]) return;
        if (r.amount <= 0) return;

        const screen = worldToScreen(r.x, r.y);
        if (screen.x < -50 || screen.x > canvas.width + 50) return;
        if (screen.y < -50 || screen.y > canvas.height + 50) return;

        const res = RESOURCES[r.type];
        ctx.fillStyle = res.color;
        ctx.font = `${20 * game.camera.zoom}px Arial`;
        ctx.textAlign = 'center';
        ctx.fillText('‚óè', screen.x, screen.y);
    });

    // Draw cables between machines (Factorio-style)
    if (game.cables && game.cables.length > 0) {
        game.cables.forEach(cable => {
            const fromScreen = worldToScreen(cable.from.x, cable.from.y);
            const toScreen = worldToScreen(cable.to.x, cable.to.y);

            // Skip if both endpoints are off-screen
            if ((fromScreen.x < -100 || fromScreen.x > canvas.width + 100) &&
                (toScreen.x < -100 || toScreen.x > canvas.width + 100)) return;

            const z = game.camera.zoom;
            const fromY = fromScreen.y - 25 * z;
            const toY = toScreen.y - 25 * z;

            // Calculate cable length for sag amount
            const dx = toScreen.x - fromScreen.x;
            const dy = toY - fromY;
            const length = Math.sqrt(dx * dx + dy * dy);
            const sagAmount = Math.min(length * 0.15, 25 * z); // Realistic catenary sag

            // Draw shadow first (offset toward sun direction)
            const shadowOffsetX = 4 * z;
            const shadowOffsetY = 8 * z;
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.25)';
            ctx.lineWidth = 2 * z;
            drawCatenaryWire(ctx,
                fromScreen.x + shadowOffsetX, fromY + shadowOffsetY,
                toScreen.x + shadowOffsetX, toY + shadowOffsetY,
                sagAmount);

            // Draw three parallel copper wires (like real power lines)
            const wireOffsets = [-3, 0, 3];
            wireOffsets.forEach((offset, i) => {
                // Copper gradient - darker on edges, brighter in middle
                const brightness = i === 1 ? 1.0 : 0.7;
                const r = Math.floor(205 * brightness);
                const g = Math.floor(127 * brightness);
                const b = Math.floor(50 * brightness);
                ctx.strokeStyle = `rgb(${r}, ${g}, ${b})`;
                ctx.lineWidth = (i === 1 ? 2 : 1.5) * z;

                drawCatenaryWire(ctx,
                    fromScreen.x + offset * z * 0.5, fromY + offset * z * 0.3,
                    toScreen.x + offset * z * 0.5, toY + offset * z * 0.3,
                    sagAmount + (i === 1 ? 0 : 2 * z));
            });

            // Draw electricity sparks occasionally
            if (Math.random() < 0.02) {
                const sparkPos = 0.3 + Math.random() * 0.4;
                const sparkX = fromScreen.x + dx * sparkPos;
                const sparkY = fromY + dy * sparkPos + sagAmount * Math.sin(sparkPos * Math.PI);
                ctx.fillStyle = '#aaddff';
                ctx.beginPath();
                ctx.arc(sparkX, sparkY, 2 * z, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw insulators/connectors at endpoints
            drawCableConnector(ctx, fromScreen.x, fromY, z);
            drawCableConnector(ctx, toScreen.x, toY, z);
        });
    }

    // Draw cable in progress (from cableStart to cursor)
    if (game.cableStart && selectedBuild === 'cable_tool') {
        const startScreen = worldToScreen(game.cableStart.x, game.cableStart.y);
        const z = game.camera.zoom;
        const startY = startScreen.y - 25 * z;

        // Dashed preview line
        ctx.strokeStyle = '#cd7f32aa';
        ctx.lineWidth = 2 * z;
        ctx.setLineDash([8 * z, 4 * z]);

        const dx = mouseX - startScreen.x;
        const dy = mouseY - startY;
        const length = Math.sqrt(dx * dx + dy * dy);
        const sagAmount = Math.min(length * 0.15, 25 * z);

        drawCatenaryWire(ctx, startScreen.x, startY, mouseX, mouseY, sagAmount);
        ctx.setLineDash([]);

        // Highlight the start machine with glowing border
        ctx.strokeStyle = '#cd7f32';
        ctx.lineWidth = 2 * z;
        ctx.shadowColor = '#ffaa44';
        ctx.shadowBlur = 10;
        ctx.strokeRect(
            startScreen.x - 18 * z,
            startScreen.y - 40 * z,
            36 * z,
            36 * z
        );
        ctx.shadowBlur = 0;

        // Draw connector at start
        drawCableConnector(ctx, startScreen.x, startY, z);
    }

    // Draw machines with new sprites
    game.machines.forEach(m => {
        const screen = worldToScreen(m.x, m.y);
        if (screen.x < -100 || screen.x > canvas.width + 100) return;
        if (screen.y < -100 || screen.y > canvas.height + 100) return;

        const def = MACHINES[m.type];

        // Draw sprite based on machine type
        if (SPRITES[m.type]) {
            drawSprite(m.type, screen.x, screen.y, {
                active: m.active,
                overheated: m.temperature > 80,
                charge: m.stored || 0,
                rotation: m.rotation || 0
            });
        } else {
            // Fallback for machines without sprites
            ctx.fillStyle = m.onFire ? '#ff4400' :
                           m.temperature < -20 ? '#aaddff' :
                           m.temperature < 0 ? '#88bbee' :
                           m.temperature > 80 ? '#ffaa44' : def.color;

            const size = 30 * game.camera.zoom;
            ctx.fillRect(screen.x - size/2, screen.y - size, size, size);

            ctx.fillStyle = '#fff';
            ctx.font = `${16 * game.camera.zoom}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText(def.icon, screen.x, screen.y - size/2 + 5);
        }

        // Temperature overlay
        if (m.temperature < -20) {
            // Frozen effect - ice overlay
            ctx.fillStyle = 'rgba(150, 200, 255, 0.4)';
            const size = 32 * game.camera.zoom;
            ctx.fillRect(screen.x - size/2, screen.y - size, size, size);
        }

        // HP bar if damaged
        if (m.hp < m.maxHp) {
            const barWidth = 30 * game.camera.zoom;
            const barHeight = 4 * game.camera.zoom;
            ctx.fillStyle = '#333';
            ctx.fillRect(screen.x - barWidth/2, screen.y - 70 * game.camera.zoom, barWidth, barHeight);
            ctx.fillStyle = m.hp > 50 ? '#4f4' : m.hp > 25 ? '#ff4' : '#f44';
            ctx.fillRect(screen.x - barWidth/2, screen.y - 70 * game.camera.zoom, barWidth * (m.hp / m.maxHp), barHeight);
        }

        // Fire effect overlay
        if (m.onFire) {
            drawSprite('fire', screen.x, screen.y, {});
        }
    });

    // Draw NPCs
    game.npcs.forEach(npc => {
        if (!game.explored[wrapCoord(npc.y)][wrapCoord(npc.x)]) return;

        const screen = worldToScreen(npc.x, npc.y);
        if (screen.x < -50 || screen.x > canvas.width + 50) return;

        ctx.font = `${24 * game.camera.zoom}px Arial`;
        ctx.textAlign = 'center';
        ctx.fillText(npc.icon, screen.x, screen.y);

        ctx.fillStyle = '#fff';
        ctx.font = `${10 * game.camera.zoom}px Arial`;
        ctx.fillText(npc.name, screen.x, screen.y + 15 * game.camera.zoom);
    });

    // Draw Sun Trackers
    game.sunTrackers.forEach(tracker => {
        const screen = worldToScreen(tracker.x, tracker.y);
        if (screen.x < -50 || screen.x > canvas.width + 50) return;
        if (screen.y < -50 || screen.y > canvas.height + 50) return;

        // Draw the tracker robot
        ctx.fillStyle = tracker.state === 'collecting' ? '#ffcc00' :
                       tracker.state === 'returning' ? '#ff9900' : '#888800';
        ctx.font = `${20 * game.camera.zoom}px Arial`;
        ctx.textAlign = 'center';
        ctx.fillText('‚òÄÔ∏è', screen.x, screen.y);

        // Charge indicator
        if (tracker.charge > 0) {
            ctx.fillStyle = '#ffff00';
            ctx.font = `${8 * game.camera.zoom}px Arial`;
            ctx.fillText(`${Math.floor(tracker.charge)}%`, screen.x, screen.y + 12 * game.camera.zoom);
        }
    });

    // Draw robot
    if (!game.robot.frozen || Math.floor(Date.now() / 500) % 2 === 0) {
        const robotScreen = worldToScreen(game.robot.x, game.robot.y);
        const isMoving = keys.w || keys.a || keys.s || keys.d;
        drawSprite('robot', robotScreen.x, robotScreen.y, {
            frozen: game.robot.frozen,
            moving: isMoving
        });
    }

    // Draw particles
    game.particles.forEach(p => {
        const screen = worldToScreen(p.x, p.y);
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.life;
        ctx.beginPath();
        ctx.arc(screen.x, screen.y, 5 * game.camera.zoom, 0, Math.PI * 2);
        ctx.fill();
    });
    ctx.globalAlpha = 1;

    // Draw build preview
    if (selectedBuild) {
        const worldPos = screenToWorld(mouseX, mouseY);
        const screen = worldToScreen(Math.floor(worldPos.x), Math.floor(worldPos.y));
        const def = MACHINES[selectedBuild];

        ctx.globalAlpha = 0.5;
        ctx.fillStyle = def.color;
        const size = 30 * game.camera.zoom;
        ctx.fillRect(screen.x - size/2, screen.y - size, size, size);
        ctx.fillStyle = '#fff';
        ctx.font = `${16 * game.camera.zoom}px Arial`;
        ctx.textAlign = 'center';
        ctx.fillText(def.icon, screen.x, screen.y - size/2 + 5);
        ctx.globalAlpha = 1;
    }

    // Night overlay
    if (!game.isDay) {
        ctx.fillStyle = 'rgba(0, 0, 30, 0.4)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Light sources
        game.machines.forEach(m => {
            if (m.type === 'light' && m.powered) {
                const screen = worldToScreen(m.x, m.y);
                const gradient = ctx.createRadialGradient(screen.x, screen.y, 0, screen.x, screen.y, 100 * game.camera.zoom);
                gradient.addColorStop(0, 'rgba(255, 255, 200, 0.3)');
                gradient.addColorStop(1, 'rgba(255, 255, 200, 0)');
                ctx.fillStyle = gradient;
                ctx.fillRect(screen.x - 100, screen.y - 100, 200, 200);
            }
        });
    }

    // Render minimap
    renderMinimap();
}

function drawIsometricTile(x, y, color, lightLevel = 1.0) {
    const w = CONFIG.TILE_WIDTH * game.camera.zoom / 2;
    const h = CONFIG.TILE_HEIGHT * game.camera.zoom / 2;

    // Apply light level to color
    // Parse the color and darken based on light level
    let finalColor = color;
    if (lightLevel < 1.0) {
        // Convert hex color to RGB, apply lighting, convert back
        const hex = color.replace('#', '');
        const r = Math.floor(parseInt(hex.substr(0, 2), 16) * lightLevel);
        const g = Math.floor(parseInt(hex.substr(2, 2), 16) * lightLevel);
        const b = Math.floor(parseInt(hex.substr(4, 2), 16) * lightLevel);
        finalColor = `rgb(${r}, ${g}, ${b})`;
    }

    ctx.fillStyle = finalColor;
    ctx.beginPath();
    ctx.moveTo(x, y - h);
    ctx.lineTo(x + w, y);
    ctx.lineTo(x, y + h);
    ctx.lineTo(x - w, y);
    ctx.closePath();
    ctx.fill();

    // Adjust stroke based on light level too
    const strokeAlpha = 0.1 * lightLevel;
    ctx.strokeStyle = `rgba(255,255,255,${strokeAlpha})`;
    ctx.stroke();
}

function getTileColor(type) {
    switch(type) {
        case 'snow': return '#ddeeff';
        case 'ice': return '#aaccee';
        case 'rock': return '#556677';
        default: return '#667788';
    }
}

function renderMinimap() {
    minimapCtx.fillStyle = '#111';
    minimapCtx.fillRect(0, 0, 150, 150);

    const scale = 150 / CONFIG.MAP_SIZE;

    // Draw explored areas
    minimapCtx.fillStyle = '#335';
    for (let y = 0; y < CONFIG.MAP_SIZE; y += 8) {
        for (let x = 0; x < CONFIG.MAP_SIZE; x += 8) {
            if (game.explored[y][x]) {
                minimapCtx.fillRect(x * scale, y * scale, 8 * scale, 8 * scale);
            }
        }
    }

    // Draw machines
    minimapCtx.fillStyle = '#4f4';
    game.machines.forEach(m => {
        minimapCtx.fillRect(m.x * scale - 1, m.y * scale - 1, 2, 2);
    });

    // Draw robot
    minimapCtx.fillStyle = '#ff0';
    minimapCtx.fillRect(game.robot.x * scale - 2, game.robot.y * scale - 2, 4, 4);
}

// ==================== UI UPDATES ====================
function updateUI() {
    // Resources
    const counts = {};
    game.robot.inventory.forEach(item => {
        counts[item.type] = (counts[item.type] || 0) + item.count;
    });

    document.getElementById('res-iron').textContent = counts['iron_ore'] || 0;
    document.getElementById('res-copper').textContent = counts['copper_ore'] || 0;
    document.getElementById('res-coal').textContent = counts['coal'] || 0;
    document.getElementById('res-crystal').textContent = counts['crystal'] || 0;
    document.getElementById('res-credits').textContent = game.credits;

    // Robot status
    document.getElementById('batteryPercent').textContent = `${Math.floor(game.robot.battery)}%`;
    document.getElementById('batteryBar').style.width = `${game.robot.battery}%`;
    document.getElementById('batteryBar').style.background =
        game.robot.battery > 50 ? '#4f4' : game.robot.battery > 25 ? '#ff4' : '#f44';

    const tempStatus = game.robot.temperature < -20 ? 'FROZEN' :
                       game.robot.temperature < 0 ? 'COLD' :
                       game.robot.temperature > 50 ? 'HOT' : 'OK';
    document.getElementById('robotTempVal').textContent = tempStatus;
    document.getElementById('tempBar').style.width = `${Math.min(100, (game.robot.temperature + 30) * 2)}%`;

    document.getElementById('robotHPVal').textContent = `${Math.floor(game.robot.hp)}%`;
    document.getElementById('hpBar').style.width = `${game.robot.hp}%`;

    // Temperature indicator
    const planetTemp = CONFIG.PLANETS[game.planet].baseTemp + (game.isDay ? 30 : 0);
    document.getElementById('tempIndicator').textContent = `üå°Ô∏è ${planetTemp}¬∞C`;
}

// ==================== INVENTORY ====================
function toggleInventory() {
    const panel = document.getElementById('inventoryPanel');
    const isHidden = panel.style.display === 'none' || panel.style.display === '';
    panel.style.display = isHidden ? 'flex' : 'none';

    if (isHidden) {
        renderInventory();
    }
}

function renderInventory() {
    const grid = document.getElementById('inventoryGrid');
    grid.innerHTML = '';

    for (let i = 0; i < CONFIG.INVENTORY_SIZE; i++) {
        const slot = document.createElement('div');
        slot.className = 'inv-slot';

        const item = game.robot.inventory[i];
        if (item) {
            const res = RESOURCES[item.type];
            slot.innerHTML = `
                <div class="item-icon" style="color: ${res?.color || '#fff'}">${res?.icon || '?'}</div>
                <div class="item-count">${item.count}</div>
                <div style="font-size: 9px; opacity: 0.7;">${res?.name || item.type}</div>
            `;
            slot.title = res?.name || item.type;
            slot.style.borderColor = res?.color || 'var(--ui-border)';
        } else {
            slot.innerHTML = '<div style="opacity: 0.3;">Empty</div>';
        }

        grid.appendChild(slot);
    }
}

// ==================== MACHINE INTERACTION ====================
function showMachineInfo(machine) {
    const def = MACHINES[machine.type];
    const info = document.getElementById('selectedInfo');

    info.innerHTML = `
        <h4 style="color: var(--ui-accent);">${def.name}</h4>
        <p style="font-size: 11px; margin: 5px 0;">${def.description}</p>
        <p style="font-size: 11px;">HP: ${Math.floor(machine.hp)}/${machine.maxHp}</p>
        <p style="font-size: 11px;">Temp: ${Math.floor(machine.temperature)}¬∞C</p>
        <p style="font-size: 11px;">Status: ${machine.onFire ? 'üî• ON FIRE' : machine.active ? '‚úì Active' : '‚úó Inactive'}</p>
        ${machine.inventory.length > 0 ? `<p style="font-size: 11px;">Storage: ${machine.inventory.map(i => `${i.count}x ${i.type}`).join(', ')}</p>` : ''}
    `;
}

function showMachineMenu(machine, x, y) {
    const menu = document.getElementById('machineMenu');
    const def = MACHINES[machine.type];
    const idx = game.machines.indexOf(machine);

    let html = `
        <h3>${def.name}</h3>
        <div class="machine-stat">HP: ${Math.floor(machine.hp)}/${machine.maxHp}</div>
        <div class="machine-stat">Temperature: ${Math.floor(machine.temperature)}¬∞C</div>
        <div class="machine-stat">Status: ${machine.onFire ? 'üî• ON FIRE' : machine.active ? '‚úì Active' : '‚úó Inactive'}</div>
    `;

    // Show processing progress for processing machines
    if (machine.processing) {
        const progress = (machine.processTime / machine.processing.time * 100).toFixed(0);
        html += `<div class="machine-stat">Processing: ${progress}%</div>`;
    }

    // Show inventory
    if (machine.inventory.length > 0) {
        html += `<div class="machine-stat">Contents:</div>`;
        machine.inventory.forEach(item => {
            const res = RESOURCES[item.type];
            html += `<div class="machine-stat" style="margin-left: 10px;">
                ${res?.icon || '?'} ${res?.name || item.type}: ${item.count}
                <span style="color: var(--ui-accent); cursor: pointer;" onclick="takeFromMachine(${idx}, '${item.type}', 1)">[Take]</span>
            </div>`;
        });
    }

    // Add items button for processing machines
    if (['furnace', 'assembler', 'fuel_refinery', 'storage'].includes(machine.type)) {
        html += `<button class="pause-btn" onclick="openTransferMenu(${idx})">Add Items</button>`;
    }

    // Special buttons
    if (machine.type === 'landing_pad') {
        html += `<button class="pause-btn" onclick="closeMachineMenu(); openTravelModal();">üöÄ Travel</button>`;
    }

    html += `
        <button class="pause-btn" onclick="pickupMachine(${idx})">Pick Up</button>
        <button class="pause-btn" onclick="closeMachineMenu()">Close</button>
    `;

    menu.innerHTML = html;
    menu.style.left = x + 'px';
    menu.style.top = y + 'px';
    menu.style.display = 'block';
}

function takeFromMachine(machineIdx, type, count) {
    const machine = game.machines[machineIdx];
    if (!machine) return;

    const item = machine.inventory.find(i => i.type === type);
    if (!item || item.count < count) return;

    item.count -= count;
    if (item.count <= 0) {
        machine.inventory = machine.inventory.filter(i => i.count > 0);
    }

    addToInventory(type, count);
    notify(`Took ${count} ${RESOURCES[type]?.name || type}`);

    // Refresh menu
    const menuPos = document.getElementById('machineMenu');
    showMachineMenu(machine, parseInt(menuPos.style.left), parseInt(menuPos.style.top));
}

function openTransferMenu(machineIdx) {
    const machine = game.machines[machineIdx];
    if (!machine) return;

    closeMachineMenu();

    const modal = document.getElementById('tradeModal');
    const title = document.getElementById('tradeTitle');
    const content = document.getElementById('tradeContent');

    title.textContent = `Transfer to ${MACHINES[machine.type].name}`;

    let html = '<div class="trade-section"><h3>Your Inventory</h3><div class="trade-grid">';

    game.robot.inventory.forEach(item => {
        const res = RESOURCES[item.type];
        html += `
            <div class="trade-item" onclick="transferToMachine(${machineIdx}, '${item.type}', 1)">
                <div class="icon">${res?.icon || '?'}</div>
                <div class="name">${res?.name || item.type} (x${item.count})</div>
                <div class="price">Click to add</div>
            </div>
        `;
    });

    if (game.robot.inventory.length === 0) {
        html += '<div style="color: var(--ui-text); grid-column: span 3; text-align: center;">Inventory empty</div>';
    }

    html += '</div></div>';
    content.innerHTML = html;
    modal.style.display = 'block';
}

function transferToMachine(machineIdx, type, count) {
    const machine = game.machines[machineIdx];
    if (!machine) return;

    const item = game.robot.inventory.find(i => i.type === type);
    if (!item || item.count < count) return;

    item.count -= count;
    if (item.count <= 0) {
        game.robot.inventory = game.robot.inventory.filter(i => i.count > 0);
    }

    addToMachineInventory(machine, type, count);
    notify(`Added ${count} ${RESOURCES[type]?.name || type} to ${MACHINES[machine.type].name}`);

    // Refresh transfer menu
    openTransferMenu(machineIdx);
}

function closeMachineMenu() {
    document.getElementById('machineMenu').style.display = 'none';
}

function pickupMachine(index) {
    const machine = game.machines[index];
    if (!machine) return;

    // Return some materials
    const def = MACHINES[machine.type];
    for (const [resource, count] of Object.entries(def.cost)) {
        addToInventory(resource, Math.floor(count * 0.5));
    }

    game.machines.splice(index, 1);
    closeMachineMenu();
    notify(`Picked up ${def.name}`);
}

// ==================== RESOURCE GATHERING ====================
function mineResource(resource) {
    if (resource.amount <= 0) return;

    const amount = Math.min(5, resource.amount);
    resource.amount -= amount;
    addToInventory(resource.type, amount);
    game.stats.resourcesMined += amount;

    notify(`Gathered ${amount} ${RESOURCES[resource.type].name}`);
}

function addToInventory(type, count) {
    const existing = game.robot.inventory.find(i => i.type === type);
    if (existing) {
        existing.count += count;
    } else if (game.robot.inventory.length < CONFIG.INVENTORY_SIZE) {
        game.robot.inventory.push({ type, count });
    } else {
        notify('Inventory full!', 'warning');
    }
}

// ==================== NPC INTERACTION ====================
function interactWithNPC(npc) {
    openTradeModal(npc);
}

function openTradeModal(npc) {
    const modal = document.getElementById('tradeModal');
    const title = document.getElementById('tradeTitle');
    const content = document.getElementById('tradeContent');

    title.textContent = `Trading with ${npc.name}`;

    let html = '';

    // Sell section - what player can sell to NPC
    html += '<div class="trade-section"><h3>üí∞ Sell (Your Items)</h3><div class="trade-grid">';

    game.robot.inventory.forEach(item => {
        if (npc.buys.includes(item.type)) {
            const res = RESOURCES[item.type];
            const price = res.price;
            html += `
                <div class="trade-item sell" onclick="sellItem('${item.type}', 1)">
                    <div class="icon">${res.icon || '‚óè'}</div>
                    <div class="name">${res.name} (x${item.count})</div>
                    <div class="price">+${price} CR</div>
                </div>
            `;
        }
    });

    if (!game.robot.inventory.some(i => npc.buys.includes(i.type))) {
        html += '<div style="color: var(--ui-text); grid-column: span 3; text-align: center;">No items to sell</div>';
    }

    html += '</div></div>';

    // Buy section - what player can buy from NPC
    html += '<div class="trade-section"><h3>üõí Buy (From Merchant)</h3><div class="trade-grid">';

    npc.sells.forEach(machineType => {
        const machine = MACHINES[machineType];
        if (machine) {
            const canAfford = game.credits >= machine.buyPrice;
            html += `
                <div class="trade-item buy ${canAfford ? '' : 'locked'}" onclick="${canAfford ? `buyMachine('${machineType}')` : ''}">
                    <div class="icon">${machine.icon}</div>
                    <div class="name">${machine.name}</div>
                    <div class="price">${machine.buyPrice} CR</div>
                </div>
            `;
        }
    });

    html += '</div></div>';

    html += `<div style="color: var(--ui-accent); text-align: center; margin-top: 10px;">Your Credits: ${game.credits} CR</div>`;

    content.innerHTML = html;
    modal.style.display = 'block';
}

function closeTradeModal() {
    document.getElementById('tradeModal').style.display = 'none';
}

function sellItem(type, count) {
    const item = game.robot.inventory.find(i => i.type === type);
    if (!item || item.count < count) return;

    const res = RESOURCES[type];
    const price = res.price * count;

    item.count -= count;
    if (item.count <= 0) {
        game.robot.inventory = game.robot.inventory.filter(i => i.count > 0);
    }

    game.credits += price;
    notify(`Sold ${count} ${res.name} for ${price} CR`);

    // Refresh modal
    const currentNpc = game.npcs.find(n =>
        Math.abs(n.x - game.robot.x) < 3 &&
        Math.abs(n.y - game.robot.y) < 3
    );
    if (currentNpc) openTradeModal(currentNpc);
}

function buyMachine(type) {
    const machine = MACHINES[type];
    if (game.credits < machine.buyPrice) {
        notify('Not enough credits!', 'warning');
        return;
    }

    // Add machine components to inventory
    game.credits -= machine.buyPrice;

    // Give as a "kit" - add materials needed to place
    for (const [resource, count] of Object.entries(machine.cost)) {
        addToInventory(resource, count);
    }

    notify(`Bought ${machine.name} kit!`);
    closeTradeModal();
}

// ==================== PLANET TRAVEL ====================
function openTravelModal() {
    const modal = document.getElementById('travelModal');
    const content = document.getElementById('travelContent');

    // Check if player has super fuel
    const hasFuel = game.robot.inventory.some(i => i.type === 'super_fuel' && i.count >= 1);

    let html = '';

    for (const [key, planet] of Object.entries(CONFIG.PLANETS)) {
        const isCurrent = key === game.planet;
        const isLocked = !hasFuel && key !== game.planet;
        const isSpaceRock = key === 'space_rock_024';

        html += `
            <div class="planet-option ${isLocked ? 'locked' : ''} ${isCurrent ? 'current' : ''}"
                 onclick="${!isLocked && !isCurrent ? `travelToPlanet('${key}')` : ''}">
                <h4>${planet.name} ${isCurrent ? '(Current)' : ''}</h4>
                <p>Day: ${planet.dayLength === 0 ? 'None' : (planet.dayLength / 60000) + ' min'} |
                   Night: ${planet.nightLength === Infinity ? 'Always' : (planet.nightLength / 60000) + ' min'}</p>
                <p>Base Temperature: ${planet.baseTemp}¬∞C</p>
                ${isSpaceRock ? '<p class="planet-warning">‚ö†Ô∏è WARNING: Bring excess power and fuel!</p>' : ''}
                ${isLocked ? '<p style="color: #ff6666;">Requires Super Fuel</p>' : ''}
            </div>
        `;
    }

    if (!hasFuel) {
        html += '<p style="color: #ff6666; text-align: center; margin-top: 10px;">You need Super Fuel to travel!</p>';
    }

    content.innerHTML = html;
    modal.style.display = 'block';
}

function closeTravelModal() {
    document.getElementById('travelModal').style.display = 'none';
}

function travelToPlanet(planetKey) {
    // Consume super fuel
    const fuelItem = game.robot.inventory.find(i => i.type === 'super_fuel');
    if (fuelItem) {
        fuelItem.count--;
        if (fuelItem.count <= 0) {
            game.robot.inventory = game.robot.inventory.filter(i => i.count > 0);
        }
    }

    // Save current planet machines to separate storage
    // For simplicity, we'll just generate a new world

    game.planet = planetKey;
    game.dayTime = 0;
    game.machines = [];
    game.resources = [];

    // Generate new world for this planet
    generateWorld();

    // Reset robot position
    game.robot.x = 256;
    game.robot.y = 256;

    closeTravelModal();
    notify(`Arrived at ${CONFIG.PLANETS[planetKey].name}!`);

    if (planetKey === 'space_rock_024') {
        notify('‚ö†Ô∏è No daylight here! Manage your power carefully!', 'danger');
    }

    saveGame();
}

// ==================== PAUSE/MENU ====================
function togglePause() {
    game.paused = !game.paused;
    document.getElementById('pauseMenu').style.display = game.paused ? 'block' : 'none';
}

function resumeGame() {
    game.paused = false;
    document.getElementById('pauseMenu').style.display = 'none';
}

function showControls() {
    toggleKeybinds();
}

function toggleKeybinds() {
    const modal = document.getElementById('keybindsModal');
    modal.style.display = modal.style.display === 'none' ? 'block' : 'none';
}

function quitToMenu() {
    location.reload();
}

// ==================== SAVE/LOAD ====================
let currentSaveSlot = 1;

function getSaveKey(slot) {
    return `frozen_factory_save_${slot}`;
}

function saveGame() {
    const saveData = {
        version: 1,
        planet: game.planet,
        dayTime: game.dayTime,
        robot: game.robot,
        machines: game.machines,
        resources: game.resources,
        explored: game.explored,
        credits: game.credits,
        stats: game.stats,
        cheats: game.cheatsActive,
        theme: game.theme,
        sunTrackers: game.sunTrackers,
        cables: game.cables,
        savedAt: Date.now()
    };

    localStorage.setItem(getSaveKey(currentSaveSlot), JSON.stringify(saveData));
    // Silent auto-save - no notification
}

function loadGame(slot) {
    if (slot !== undefined) currentSaveSlot = slot;
    const data = localStorage.getItem(getSaveKey(currentSaveSlot));
    if (!data) return false;

    try {
        const saveData = JSON.parse(data);
        game.planet = saveData.planet;
        game.dayTime = saveData.dayTime;
        game.robot = saveData.robot;
        game.machines = saveData.machines;
        game.resources = saveData.resources;
        game.explored = saveData.explored;
        game.credits = saveData.credits;
        game.stats = saveData.stats;
        game.cheatsActive = saveData.cheats || {};
        game.theme = saveData.theme;
        game.sunTrackers = saveData.sunTrackers || [];
        game.cables = saveData.cables || [];

        applyTheme(game.theme);
        return true;
    } catch (e) {
        console.error('Failed to load save:', e);
        return false;
    }
}

function getSaveInfo(slot) {
    const data = localStorage.getItem(getSaveKey(slot));
    if (!data) return null;

    try {
        const saveData = JSON.parse(data);
        const playtime = Math.floor((saveData.stats?.playtime || 0) / 60);
        const savedAt = saveData.savedAt ? new Date(saveData.savedAt).toLocaleDateString() : 'Unknown';
        return {
            planet: CONFIG.PLANETS[saveData.planet]?.name || 'Unknown',
            playtime: `${playtime} min`,
            credits: saveData.credits || 0,
            savedAt: savedAt
        };
    } catch (e) {
        return null;
    }
}

function deleteSave(slot, event) {
    event.stopPropagation();
    if (confirm(`Delete Save Slot ${slot}?`)) {
        localStorage.removeItem(getSaveKey(slot));
        renderSaveSlots();
    }
}

function selectSaveSlot(slot) {
    currentSaveSlot = slot;
    document.querySelectorAll('.save-slot').forEach(el => el.classList.remove('selected'));
    document.getElementById(`save-slot-${slot}`).classList.add('selected');
}

function renderSaveSlots() {
    const container = document.getElementById('saveSlots');
    container.innerHTML = '';

    for (let i = 1; i <= 3; i++) {
        const info = getSaveInfo(i);
        const slot = document.createElement('div');
        slot.className = `save-slot ${i === currentSaveSlot ? 'selected' : ''}`;
        slot.id = `save-slot-${i}`;
        slot.onclick = () => selectSaveSlot(i);

        if (info) {
            slot.innerHTML = `
                <h3>Slot ${i}</h3>
                <div class="save-info exists">üåç ${info.planet}</div>
                <div class="save-info exists">‚è±Ô∏è ${info.playtime}</div>
                <div class="save-info exists">üí∞ ${info.credits} CR</div>
                <div class="save-info exists">üìÖ ${info.savedAt}</div>
                <button class="delete-save" onclick="deleteSave(${i}, event)">Delete</button>
            `;
        } else {
            slot.innerHTML = `
                <h3>Slot ${i}</h3>
                <div class="save-info">Empty</div>
                <div class="save-info">New Game</div>
            `;
        }

        container.appendChild(slot);
    }
}

// ==================== NOTIFICATIONS ====================
function notify(message, type = 'info') {
    const container = document.getElementById('notifications');
    const notif = document.createElement('div');
    notif.className = `notification ${type}`;
    notif.textContent = message;
    container.appendChild(notif);

    setTimeout(() => notif.remove(), 5000);
}

// ==================== CHEATS ====================
function closeCheatMenu() {
    document.getElementById('cheatMenu').style.display = 'none';
}

function cheatAddBattery() {
    game.robot.battery = game.robot.maxBattery;
    notify('Battery refilled!');
}

function cheatAddWarmth() {
    game.robot.temperature = 30;
    notify('Robot warmed up!');
}

function cheatAddItems() {
    addToInventory('iron_ingot', 50);
    addToInventory('copper_ingot', 50);
    addToInventory('steel', 25);
    addToInventory('circuit', 10);
    addToInventory('crystal', 20);
    game.credits += 1000;
    notify('Items and credits added!');
}

function cheatFreeCrafting() {
    game.cheatsActive.freeCrafting = !game.cheatsActive.freeCrafting;
    document.getElementById('cheatFreeCraft').classList.toggle('active');
    notify(`Free crafting: ${game.cheatsActive.freeCrafting ? 'ON' : 'OFF'}`);
}

function cheatLantern() {
    for (let y = 0; y < CONFIG.MAP_SIZE; y++) {
        for (let x = 0; x < CONFIG.MAP_SIZE; x++) {
            game.explored[y][x] = true;
        }
    }
    notify('Map revealed!');
}

function cheatNoDeath() {
    game.cheatsActive.noDeath = !game.cheatsActive.noDeath;
    document.getElementById('cheatNoDeath').classList.toggle('active');
    notify(`No death: ${game.cheatsActive.noDeath ? 'ON' : 'OFF'}`);
}

function cheatRocketLauncher() {
    game.cheatsActive.rocketLauncher = !game.cheatsActive.rocketLauncher;
    if (game.cheatsActive.rocketLauncher) {
        game.rocketMode = 'destroy'; // destroy, clear, launch
    }
    document.getElementById('cheatRocket').classList.toggle('active');
    notify(`Rocket launcher: ${game.cheatsActive.rocketLauncher ? 'ON (Mode: DESTROY - Press 1/2/3 to change)' : 'OFF'}`);
}

function cycleRocketMode() {
    const modes = ['destroy', 'clear', 'launch'];
    const currentIndex = modes.indexOf(game.rocketMode);
    game.rocketMode = modes[(currentIndex + 1) % modes.length];
    notify(`Rocket mode: ${game.rocketMode.toUpperCase()}`);
}

function fireRocket(worldX, worldY) {
    if (!game.cheatsActive.rocketLauncher) return;

    const wx = wrapCoord(Math.floor(worldX));
    const wy = wrapCoord(Math.floor(worldY));

    // Create explosion particles
    for (let i = 0; i < 20; i++) {
        game.particles.push({
            x: worldX,
            y: worldY,
            vx: (Math.random() - 0.5) * 8,
            vy: (Math.random() - 0.5) * 8,
            life: 1.5,
            color: game.rocketMode === 'destroy' ? '#ff4400' :
                   game.rocketMode === 'clear' ? '#88ccff' : '#44ff88'
        });
    }

    if (game.rocketMode === 'destroy') {
        // Destroy machine at location
        const machine = getMachineAt(wx, wy);
        if (machine) {
            game.machines = game.machines.filter(m => m !== machine);
            notify('üí• Machine destroyed!');
        } else {
            notify('No machine to destroy');
        }
    } else if (game.rocketMode === 'clear') {
        // Clear terrain in radius
        for (let dy = -2; dy <= 2; dy++) {
            for (let dx = -2; dx <= 2; dx++) {
                const tx = wrapCoord(wx + dx);
                const ty = wrapCoord(wy + dy);
                if (game.tiles[ty] && game.tiles[ty][tx]) {
                    game.tiles[ty][tx].type = 'snow';
                }
                // Remove resource nodes in blast
                game.resources = game.resources.filter(r =>
                    !(r.x === tx && r.y === ty)
                );
            }
        }
        notify('üí• Terrain cleared!');
    } else if (game.rocketMode === 'launch') {
        // Launch robot to location
        game.robot.x = worldX;
        game.robot.y = worldY;
        game.camera.following = true;
        notify('üöÄ Robot launched!');
    }
}

// ==================== PARTICLES ====================
function updateParticles(dt) {
    game.particles = game.particles.filter(p => {
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.life -= dt;
        return p.life > 0;
    });
}

// ==================== SUN TRACKER ROBOTS ====================
function updateSunTrackers(dt) {
    game.sunTrackers.forEach(tracker => {
        // States: 'collecting', 'returning', 'depositing', 'waiting'

        if (tracker.state === 'waiting') {
            // Wait for daytime to start collecting
            if (game.isDay) {
                tracker.state = 'collecting';
                tracker.charge = 0;
            }
            return;
        }

        if (tracker.state === 'collecting') {
            // Move toward daylight (follow the sun)
            const sunX = getSunPosition();
            const lightLevel = getTileLightLevel(tracker.x);

            if (lightLevel > 0.3) {
                // We're in daylight - follow the sun and collect energy
                tracker.wanderTimer = (tracker.wanderTimer || 0) + dt;
                if (tracker.wanderTimer > 2) {
                    // Move toward the sun position, with some random offset
                    // Calculate direction to sun (accounting for wrap-around)
                    let dirToSun = sunX - tracker.x;
                    if (dirToSun > CONFIG.MAP_SIZE / 2) dirToSun -= CONFIG.MAP_SIZE;
                    if (dirToSun < -CONFIG.MAP_SIZE / 2) dirToSun += CONFIG.MAP_SIZE;

                    // Target is ahead of the sun (to stay in daylight)
                    tracker.targetX = tracker.x + Math.sign(dirToSun) * 15 + (Math.random() - 0.5) * 10;
                    tracker.targetY = tracker.y + (Math.random() - 0.5) * 15;
                    tracker.wanderTimer = 0;
                }

                // Move toward target
                let dx = (tracker.targetX || tracker.x) - tracker.x;
                let dy = (tracker.targetY || tracker.y) - tracker.y;
                // Handle wrap-around for movement
                if (dx > CONFIG.MAP_SIZE / 2) dx -= CONFIG.MAP_SIZE;
                if (dx < -CONFIG.MAP_SIZE / 2) dx += CONFIG.MAP_SIZE;

                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 1) {
                    tracker.x += (dx / dist) * 2 * dt;
                    tracker.y += (dy / dist) * 2 * dt;
                }

                // Wrap coordinates
                tracker.x = wrapCoord(tracker.x);
                tracker.y = wrapCoord(tracker.y);

                // Collect solar energy (more in brighter areas)
                tracker.charge += 5 * lightLevel * dt;

                // When fully charged, return home
                if (tracker.charge >= 100) {
                    tracker.state = 'returning';
                }
            } else {
                // We've fallen into darkness - immediately head toward daylight!
                let dirToSun = sunX - tracker.x;
                if (dirToSun > CONFIG.MAP_SIZE / 2) dirToSun -= CONFIG.MAP_SIZE;
                if (dirToSun < -CONFIG.MAP_SIZE / 2) dirToSun += CONFIG.MAP_SIZE;

                // Sprint toward the sun
                tracker.x += Math.sign(dirToSun) * 4 * dt;
                tracker.x = wrapCoord(tracker.x);

                // Check if still no light after trying, give up and return home
                const newLight = getTileLightLevel(tracker.x);
                if (newLight < 0.3 && tracker.charge > 20) {
                    // Too dark, return with what we have
                    tracker.state = 'returning';
                }
            }
        }

        if (tracker.state === 'returning') {
            // Move back to home battery bank
            const dx = tracker.homeX - tracker.x;
            const dy = tracker.homeY - tracker.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist > 1) {
                tracker.x += (dx / dist) * 3 * dt;
                tracker.y += (dy / dist) * 3 * dt;
            } else {
                tracker.state = 'depositing';
            }

            // Wrap coordinates
            tracker.x = wrapCoord(tracker.x);
            tracker.y = wrapCoord(tracker.y);

            // Drain some energy for movement
            tracker.charge -= 0.5 * dt;
            if (tracker.charge < 0) tracker.charge = 0;
        }

        if (tracker.state === 'depositing') {
            // Find battery bank at home
            const bank = game.machines.find(m =>
                m.type === 'battery_bank' &&
                Math.abs(m.x - tracker.homeX) < 2 &&
                Math.abs(m.y - tracker.homeY) < 2
            );

            if (bank && tracker.charge > 0) {
                // Deposit charge
                const deposit = Math.min(tracker.charge, 50);
                bank.stored = (bank.stored || 0) + deposit;
                tracker.charge = 0;
                notify(`Sun Tracker deposited ${Math.floor(deposit)} energy`);
            }

            // Wait for next day
            tracker.state = 'waiting';
        }
    });
}

function spawnSunTracker(bankMachine) {
    const tracker = {
        x: bankMachine.x,
        y: bankMachine.y,
        homeX: bankMachine.x,
        homeY: bankMachine.y,
        charge: 0,
        state: game.isDay ? 'collecting' : 'waiting',
        targetX: bankMachine.x,
        targetY: bankMachine.y,
        wanderTimer: 0
    };
    game.sunTrackers.push(tracker);
    notify('Sun Tracker deployed!');
}

// ==================== GAME LOOP ====================
let lastTime = 0;

function gameLoop(time) {
    const dt = Math.min((time - lastTime) / 1000, 0.1);
    lastTime = time;

    if (game.running && !game.paused) {
        updateRobot(dt);
        updateMachines(dt);
        updateDayNight(dt);
        updateParticles(dt);
        updateSunTrackers(dt);
        game.stats.playtime += dt;
        animationFrame++;
    }

    render();
    updateUI();

    requestAnimationFrame(gameLoop);
}

// ==================== START GAME ====================
function startGame() {
    // Try to load selected save slot
    if (!loadGame(currentSaveSlot)) {
        generateWorld();
    }

    initBuildMenu();

    // Auto-save interval
    setInterval(() => {
        if (game.running) saveGame();
    }, CONFIG.SAVE_INTERVAL);

    game.running = true;
    notify(`Welcome to Frozen Factory! (Slot ${currentSaveSlot})`);
    notify('Use WASD to move, Tab for build menu');

    requestAnimationFrame(gameLoop);
}

// Migrate old single save to slot 1 if it exists
const oldSave = localStorage.getItem('frozen_factory_save');
if (oldSave && !localStorage.getItem('frozen_factory_save_1')) {
    localStorage.setItem('frozen_factory_save_1', oldSave);
    localStorage.removeItem('frozen_factory_save');
}

// Initialize save slots display on page load
renderSaveSlots();
</script>
</body>
</html>
